<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<script>
    // 【关键修改】：立即执行，在任何其他代码之前保存参数
    (function() {
      const urlParams = new URLSearchParams(window.location.search);
      
      // 如果 URL 中有配置参数，立即保存到 sessionStorage
      if (urlParams.get('module') || urlParams.get('meetingType')) {
        const config = {
          role: urlParams.get('role') || 'student',
          module: urlParams.get('module') || 'DE4 ERO',
          meetingType: urlParams.get('meetingType') || 'brainstorming',
          projectWeek: urlParams.get('projectWeek') || '',
          groupName: urlParams.get('groupName') || '',
          groupNumber: urlParams.get('groupNumber') || '',
          meetingGoals: decodeURIComponent(urlParams.get('meetingGoals') || ''),
          teamMembers: (urlParams.get('teamMembers') || '').split('|').filter(Boolean)
        };
        
        // 保存到 sessionStorage（页面刷新后仍然存在）
        sessionStorage.setItem('meetingConfig', JSON.stringify(config));
        console.log('💾 立即保存配置到 sessionStorage:', config);
      }
    })();
  </script>
  <style>
    body { font-family: sans-serif; padding: 16px; }
    button { padding: 8px 16px; margin-right: 8px; }
    textarea { width: 100%; height: 200px; margin-top: 12px; white-space: pre-wrap; }
    /* 新增样式 */
    .status-panel {
      background: #f0f0f0;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      font-size: 14px;
    }
    .status-line {
      margin: 5px 0;
    }
  </style>
</head>
<body>
 
<div class="config-info" style="background: #d4edda; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
  <strong>Recording Configuration:</strong><br>
  Processing: Every 5 minutes<br>
  Auto-summarize: Every <span id="intervalMin"></span> minutes (after <span id="segmentsNeeded"></span> segments)
</div>


  <h2>🎙️ Record Meeting</h2>
  <div class="status-panel" style="position: fixed; top: 10px; right: 10px; background: white; padding: 10px; border: 1px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
  <div id="recordingTime">⏱️ Not recording</div>
  <div id="audioLevel">🎤 No audio</div>
  <div id="segmentProgress">📊 Waiting...</div>
</div>
   <div class="status-panel">
    <div class="status-line" id="recordingStatus"></div>
    <div class="status-line" id="segmentStatus"></div>
  </div>
  
  <button id="startBtn">Start</button>
  <button id="stopBtn" disabled>Stop</button>
  
  <textarea id="textArea" placeholder="Transcript and summary will appear here..."></textarea>

  <script>
    
    const urlParams = new URLSearchParams(window.location.search);
    const sessionId = urlParams.get("session");
    // ========== 配置常量 - 修改为3分钟 ==========
    const SEGMENT_DURATION = 5 * 60 * 1000;  // 改为3分钟 (原本是30秒)
    const intervalMin = parseInt(urlParams.get("intervalMin") || "10");  // 默认10分钟

      let formDataFromUrl;
    const savedConfig = sessionStorage.getItem('meetingConfig');
    
    if (savedConfig) {
      // 情况1：从 sessionStorage 恢复（页面刷新后）
      formDataFromUrl = JSON.parse(savedConfig);
      console.log('✅ 从 sessionStorage 恢复配置:', formDataFromUrl);
    } else if (urlParams.get('module') || urlParams.get('meetingType')) {
      // 情况2：从 URL 参数解析（首次加载）
      formDataFromUrl = {
        role: urlParams.get('role') || 'student',
        module: urlParams.get('module') || 'DE4 ERO',
        meetingType: urlParams.get('meetingType') || 'brainstorming',
        projectWeek: urlParams.get('projectWeek') || '',
        groupName: urlParams.get('groupName') || '',
        groupNumber: urlParams.get('groupNumber') || '',
        meetingGoals: decodeURIComponent(urlParams.get('meetingGoals') || ''),
        teamMembers: (urlParams.get('teamMembers') || '').split('|').filter(Boolean)
      };
      // 保存到 sessionStorage 以备后用
      sessionStorage.setItem('meetingConfig', JSON.stringify(formDataFromUrl));
      console.log('📥 从 URL 解析并保存配置:', formDataFromUrl);
    } else {
      // 情况3：使用默认值（没有配置信息）
      formDataFromUrl = {
        role: 'student',
        module: 'DE4 ERO',
        meetingType: 'brainstorming',
        projectWeek: '',
        groupName: '',
        groupNumber: '',
        meetingGoals: '',
        teamMembers: []
      };
      console.log('⚠️ 使用默认配置:', formDataFromUrl);
    }

   // 显示接收到的配置，便于调试
  console.log('📋 录音页面配置:', {
    sessionId,
    intervalMin,
    formData: formDataFromUrl
  });
  
    const SUMMARIZE_FREQUENCY = Math.ceil(intervalMin / 5);  // 计算需要几个segments

    window.onload = function() {
    const intervalElement = document.getElementById('intervalMin');
    const segmentsElement = document.getElementById('segmentsNeeded');
    
    if (intervalElement) intervalElement.textContent = intervalMin;
    if (segmentsElement) segmentsElement.textContent = SUMMARIZE_FREQUENCY;

    // 显示模块和会议类型
    const configInfo = document.querySelector('.config-info');
    if (configInfo && formDataFromUrl.module) {
      configInfo.innerHTML += `<br>Module: ${formDataFromUrl.module}<br>Meeting Type: ${formDataFromUrl.meetingType}`;
      if (formDataFromUrl.projectWeek) {
          configInfo.innerHTML += `<br>Project: ${formDataFromUrl.projectWeek}`;
        }
        if (formDataFromUrl.teamMembers && formDataFromUrl.teamMembers.length > 0) {
          configInfo.innerHTML += `<br>Team: ${formDataFromUrl.teamMembers.join(', ')}`;
        }
    }
  };

  console.log("📊 Configuration:", {
    sessionId,
    intervalMin,
    segmentsNeeded: SUMMARIZE_FREQUENCY
  });
   
    
    // ========== 保留原有的变量 ==========
    let contextPdfText = "";
    let sessionStartTime = null;
    
   
    
    // ========== 新增双轨录音变量 ==========
    let segmentRecorder = null;       // 分段录音器
    let fullRecorder = null;           // 完整录音器
    let segmentChunks = [];            // 当前分段的音频块
    let fullRecordingChunks = [];     // 完整录音的音频块
    let segmentStream = null;          // 分段录音流
    let fullStream = null;             // 完整录音流
   
    // ========== 修改原有变量 ==========
    let transcriptChunks = [];        // 保留，存储所有转录文本
    let segmentCount = 0;             // 替代原来的recordingCycleCount
    let isRecording = false;          // 替代原来的isManuallyStopped逻辑
    let segmentTimer = null;          // 新增定时器
    
    let previousSummary = {
      summary: '',
      decision: [],
      explicit: [],
      tacit: []
    };

    // UI元素
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const textArea = document.getElementById('textArea');
    const recordingStatus = document.getElementById('recordingStatus');
    const segmentStatus = document.getElementById('segmentStatus');

    // ========== 主要修改：启动双轨录音 ==========
    startBtn.onclick = async () => {
      await startDualRecording();
    };
    
    stopBtn.onclick = async () => {
      await stopAllRecording();
    };

    // ========== 新增：双轨录音系统 ==========
    async function startDualRecording() {
      try {
        console.log("🎙️ Starting dual-track recording...");
        // 安全检查元素是否存在
    const recordingStatus = document.getElementById('recordingStatus');
    const segmentStatus = document.getElementById('segmentStatus');
    
    if (!recordingStatus || !segmentStatus) {
      console.error('❌ Status elements not found in DOM');
      // 创建缺失的元素
      if (!recordingStatus) {
        console.warn('Creating missing recordingStatus element');
      }
      if (!segmentStatus) {
        console.warn('Creating missing segmentStatus element');
      }
    }
        
        // 重置状态
        isRecording = true;
        sessionStartTime = Date.now();
        segmentCount = 0;
        transcriptChunks = [];
        segmentChunks = [];
        fullRecordingChunks = [];
        
        // 获取两个独立的音频流
        segmentStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        fullStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // 设置分段录音器
        segmentRecorder = new MediaRecorder(segmentStream, {
          mimeType: 'audio/webm;codecs=opus',
          audioBitsPerSecond: 8000  // 极低比特率 8kbps
        });
        segmentRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) segmentChunks.push(e.data);
        };
        
        // 设置完整录音器
        fullRecorder = new MediaRecorder(fullStream, {
          mimeType: 'audio/webm;codecs=opus',
          audioBitsPerSecond: 8000  // 8kbps
        });
        fullRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) fullRecordingChunks.push(e.data);
        };
        
        // 启动两个录音器
        segmentRecorder.start();
        fullRecorder.start();
        
        // UI更新
        startBtn.disabled = true;
        stopBtn.disabled = false;
        textArea.value = '🎙️ Recording started (dual-track)...';
         if (recordingStatus) {
      recordingStatus.textContent = '🔴 Recording in progress...';
    }
        
        // 启动分段处理定时器
        startSegmentTimer();
        
        console.log("✅ Both recording tracks started");
        
      } catch (err) {
        console.error('❌ Microphone error:', err);
        textArea.value = '❌ Microphone access denied.';
        resetUI();
      }
    }
    let recordingTimer = null;
    function updateRecordingTime() {
  if (!isRecording || !sessionStartTime) return;
  
  const elapsed = Date.now() - sessionStartTime;
  const minutes = Math.floor(elapsed / 60000);
  const seconds = Math.floor((elapsed % 60000) / 1000);
  
  // 计算下一个segment的剩余时间
  const nextSegmentIn = SEGMENT_DURATION - (elapsed % SEGMENT_DURATION);
  const nextMinutes = Math.floor(nextSegmentIn / 60000);
  const nextSeconds = Math.floor((nextSegmentIn % 60000) / 1000);
  
  recordingStatus.innerHTML = `
    🔴 Recording: ${minutes}:${seconds.toString().padStart(2, '0')}<br>
    ⏭️ Next segment in: ${nextMinutes}:${nextSeconds.toString().padStart(2, '0')}
  `;
}

// 在 startDualRecording 成功后启动计时器
recordingTimer = setInterval(updateRecordingTime, 1000);
// 每30秒输出一次状态（用于测试）
setInterval(() => {
  if (isRecording) {
    console.log(`📊 Status at ${new Date().toLocaleTimeString()}:`, {
      recording: true,
      segments: segmentCount,
      duration: Math.floor((Date.now() - sessionStartTime) / 60000) + ' min',
      nextSegmentIn: Math.ceil((SEGMENT_DURATION - ((Date.now() - sessionStartTime) % SEGMENT_DURATION)) / 1000) + ' sec'
    });
  }
}, 30000);
// 添加音频活动检测
async function checkAudioActivity() {
  if (!segmentStream) return;
  
  const audioContext = new AudioContext();
  const analyser = audioContext.createAnalyser();
  const microphone = audioContext.createMediaStreamSource(segmentStream);
  const dataArray = new Uint8Array(analyser.frequencyBinCount);
  
  microphone.connect(analyser);
  
  function checkLevel() {
    analyser.getByteFrequencyData(dataArray);
    const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
    
    // 显示音频级别
    const level = Math.min(100, Math.floor(average));
    const bars = '█'.repeat(Math.floor(level / 10));
    
    if (document.getElementById('audioLevel')) {
      document.getElementById('audioLevel').textContent = `Audio: ${bars} ${level}%`;
    }
    
    if (isRecording) {
      requestAnimationFrame(checkLevel);
    }
  }
  
  checkLevel();
}

    // ========== 新增：分段定时器 ==========
    function startSegmentTimer() {
      segmentTimer = setTimeout(async () => {
        if (isRecording) {
          await processSegment();
          startSegmentTimer(); // 递归调用
        }
      }, SEGMENT_DURATION);
    }

    // ========== 修改：处理分段 ==========
    async function processSegment() {
      segmentCount++;
      console.log(`📦 Processing segment ${segmentCount}...`);
      segmentStatus.textContent = `Processing segment ${segmentCount}...`;
      
      // 停止当前分段录音
      segmentRecorder.stop();
      
      // 等待数据可用
      await new Promise(resolve => {
        segmentRecorder.onstop = resolve;
      });
      
      // 创建分段blob
      const segmentBlob = new Blob(segmentChunks, { type: 'audio/webm' });

      // 检查文件大小
  const sizeMB = segmentBlob.size / 1024 / 1024;
  console.log(`📊 Segment ${segmentCount} size: ${sizeMB.toFixed(2)} MB`);
  
  if (sizeMB > 40) {
    console.error(`❌ Segment too large: ${sizeMB.toFixed(2)} MB`);
    segmentStatus.textContent = `❌ Segment ${segmentCount} too large`;
    segmentChunks = []; // 清空
    // 继续录音但跳过这个segment
  } else {
    await transcribeSegment(segmentBlob);
  }
      segmentChunks = []; // 重置
      
      // 发送分段进行转录
      await transcribeSegment(segmentBlob);
      
      // 重启分段录音器
      if (isRecording) {
        segmentStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        segmentRecorder = new MediaRecorder(segmentStream , {
          mimeType: 'audio/webm;codecs=opus',
          audioBitsPerSecond: 8000  // 确保低比特率
        });
        segmentRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) segmentChunks.push(e.data);
        };
        segmentRecorder.start();
      }
      
      // 检查是否需要总结
      if (segmentCount % SUMMARIZE_FREQUENCY === 0) {
        await performIntermediateSummary();
      }
    }

    // ========== 修改：转录分段（使用AssemblyAI） ==========
    async function transcribeSegment(blob) {
      // 显示文件大小
  const sizeMB = blob.size / 1024 / 1024;
  console.log(`📁 Uploading segment ${segmentCount}: ${sizeMB.toFixed(2)} MB`);
  
  if (sizeMB > 45) {
    throw new Error(`File too large: ${sizeMB.toFixed(2)} MB (max 45 MB)`);
  }
  const form = new FormData();
  form.append('file', blob, `segment_${segmentCount}.webm`);
  
  try {
    textArea.value = `🔄 Transcribing segment ${segmentCount} with speaker detection...`;
    
    const res = await fetch('https://fyp-2025-kath.vercel.app/api/analyze', {
      method: 'POST',
      body: form
    });

    // 先检查响应状态
    if (!res.ok) {
      const errorText = await res.text();
      console.error('❌ API error:', res.status, errorText);
      throw new Error(`API returned ${res.status}: ${errorText}`);
    }

    // 获取响应文本
    const responseText = await res.text();
    console.log('📥 Raw response:', responseText.substring(0, 100)); // 只显示前100字符
    
    
  // 尝试解析JSON
    let result;
    try {
      result = JSON.parse(responseText);
    } catch (parseError) {
      console.error('❌ JSON parse error:', parseError);
      console.error('Response was:', responseText);
      throw new Error('Invalid JSON response from API');
    }
    
    if (result.success) {
      // 存储带说话人标签的转录
      transcriptChunks.push(result.transcript);
      
      const duration = Math.floor((Date.now() - sessionStartTime) / 60000);
      
      // 计算总结进度
      const currentProgress = segmentCount % SUMMARIZE_FREQUENCY;
      const segmentsUntilSummary = currentProgress === 0 ? 
        SUMMARIZE_FREQUENCY : 
        SUMMARIZE_FREQUENCY - currentProgress;
      const minutesUntilSummary = segmentsUntilSummary * 5;
      
      textArea.value = `⏱️ Recording time: ${duration} min\n` +
                      `📝 Sgment ${segmentCount} transcribed\n` +
                      `👥 Speakers detected: ${result.metadata?.speakers || 0}\n` +
                      `📊 Progress: ${currentProgress || SUMMARIZE_FREQUENCY}/${SUMMARIZE_FREQUENCY} segments\n` +
                      `⏭️ Next summary: ${segmentsUntilSummary} segment${segmentsUntilSummary > 1 ? 's' : ''} (${minutesUntilSummary} min)\n\n` +
                      `Latest transcript:\n${result.transcript}`;
      
      segmentStatus.textContent = `✅ Segment ${segmentCount} processed`;
    } else {
      throw new Error(result.error || 'Transcription failed');
    }
    
  } catch (err) {
    console.error('❌ Segment transcription failed:', err);
    segmentStatus.textContent = `❌ Segment ${segmentCount} failed: ${err.message}`;
    // 显示错误但继续录音
    textArea.value = `❌ Segment ${segmentCount} failed to transcribe\n` +
                    `Error: ${err.message}\n` +
                    `Continuing recording...\n\n` +
                    textArea.value;
  }
}
    // ========== 修改：中间总结（保持原有逻辑） ==========
    async function performIntermediateSummary() {
      const combined = transcriptChunks.join('\n\n');
      const duration = Math.floor((Date.now() - sessionStartTime) / 60000);
      
      console.log('📊 Generating intermediate summary...');
      console.log('📋 使用配置:', formDataFromUrl); // 调试信息
      textArea.value += '\n\n📊 Generating summary...';
      
      try {
        const avoidCombined = [
          previousSummary.summary,
          ...previousSummary.decision,
          ...previousSummary.explicit,
          ...previousSummary.tacit
        ].join('\n');

        const requestBody = {
          text: combined,
          avoid: avoidCombined,
          session_id: sessionId,
          form_data: formDataFromUrl  // 添加表单配置数据
        };

        console.log('📤 发送到 API 的配置:', requestBody.form_data);

        const res = await fetch('https://fyp-2025-kath.vercel.app/api/summarize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });
        
        const data = await res.json();
        
        if (data.summary) {
          // 更新previousSummary
          previousSummary.summary += '\n' + data.summary;
          previousSummary.decision = [...previousSummary.decision, ...(data.decision || [])];
          previousSummary.explicit = [...previousSummary.explicit, ...(data.explicit || [])];
          previousSummary.tacit = [...previousSummary.tacit, ...(data.tacit || [])];
          
          textArea.value = `📊 Summary (${duration} min):\n${data.summary}\n\n` +
                          `Continue recording...`;
          
          // 保存中间总结
          await saveIntermediateSummary(data);
        }
        
      } catch (err) {
        console.error('❌ Summary failed:', err);
      }
    }

    // ========== 新增：停止所有录音并处理完整录音 ==========
    async function stopAllRecording() {
      console.log('🛑 Stopping all recording...');
      isRecording = false;
      
      // 清除定时器
      if (segmentTimer) {
        clearTimeout(segmentTimer);
        segmentTimer = null;
      }
      
      // 停止分段录音器
      if (segmentRecorder && segmentRecorder.state === 'recording') {
        segmentRecorder.stop();
      }
      
      // 停止完整录音器
      if (fullRecorder && fullRecorder.state === 'recording') {
        fullRecorder.stop();
        
        // 等待数据
        await new Promise(resolve => {
          fullRecorder.onstop = resolve;
        });
      }
      
      // 处理完整录音
      await processFinalRecording();
      
      // 重置UI
      resetUI();
    }

    // ========== 新增：处理完整录音 ==========
    async function processFinalRecording() {

      console.log('🔍 检查 sessionStorage:', sessionStorage.getItem('formConfig'));
      if (fullRecordingChunks.length === 0) {
        console.warn('No full recording data');
        return;
      }
      
      console.log('🎯 Processing complete recording...');
      textArea.value = '🎯 Processing complete recording for final summary...\n' +
                      'This may take a few minutes...';
      
      const fullBlob = new Blob(fullRecordingChunks, { type: 'audio/webm' });
      const duration = Math.floor((Date.now() - sessionStartTime) / 60000);
      
      console.log(`📼 Full recording: ${(fullBlob.size / 1024 / 1024).toFixed(2)} MB, ${duration} min`);
      
      const form = new FormData();
      form.append('file', fullBlob, 'full_recording.webm');
      form.append('session_id', sessionId);
      form.append('duration_minutes', duration.toString());

  //      // ✅ 新增：收集并添加form_data
  // const formDataObj = {
  //   // 基本配置
  //   role: document.getElementById('role')?.value || 'student',
  //   module: document.getElementById('module')?.value || '',
  //   meetingType: document.getElementById('meeting-type')?.value || '',
  //   projectWeek: document.getElementById('project-week')?.value || '',
    
  //   // 团队信息
  //   groupName: document.getElementById('group-name')?.value || '',
  //   groupNumber: document.getElementById('group-number')?.value || '',
    
  //   // 团队成员（转换为数组）
  //   teamMembers: (function() {
  //     const membersInput = document.getElementById('team-members')?.value || '';
  //     return membersInput.split(',').map(m => m.trim()).filter(m => m);
  //   })(),
    
  //   // 会议目标
  //   meetingGoals: document.getElementById('meeting-goals')?.value || '',
    
  //   // 上周会议纪要（重要！）
  //   previousSummary: document.getElementById('previous-summary')?.value || '',
    
    
  // };

  const formDataObj = JSON.parse(sessionStorage.getItem('meetingConfig') || '{}');
  console.log('📝 从 sessionStorage 获取的配置:', formDataObj);

    // 将form_data添加到FormData
  form.append('form_data', JSON.stringify(formDataObj));
  
  // 添加调试日志
  console.log('📝 Sending form_data with final recording:', {
    role: formDataObj.role,
    module: formDataObj.module,
    meetingType: formDataObj.meetingType,
    projectWeek: formDataObj.projectWeek,
    teamSize: formDataObj.teamMembers.length,
    //hasPreviousSummary: (formDataObj.previousSummary?.length || 0) > 0,
    //hasGoals: (formDataObj.meetingGoals?.length || 0) > 0
    hasPreviousSummary: Boolean(formDataObj.previousSummary),
  hasGoals: Boolean(formDataObj.meetingGoals)
  });


      
      try {
        // 发送到新的final-analyze端点
        const res = await fetch('https://fyp-2025-kath.vercel.app/api/final-analyze', {
          method: 'POST',
          body: form
        });
        
        const result = await res.json();
        
        if (result.success) {

          // 格式化输出，包含决策的详细信息
      let decisionsText = 'None';
      if (result.decisions && result.decisions.length > 0) {
        decisionsText = result.decisions.map((d, i) => {
          // 如果决策已经包含了Explicit和Tacit，直接显示
          if (d.includes('Explicit:') && d.includes('Tacit:')) {
            return d;
          }
          // 否则尝试从separate arrays中匹配
          const explicit = result.explicit?.[i] || '';
          const tacit = result.tacit?.[i] || '';
          return `${d}\n  → Explicit: ${explicit}\n  → Tacit: ${tacit}`;
        }).join('\n\n');
      }
          textArea.value = `✨ FINAL MEETING SUMMARY ✨\n` +
                      `Duration: ${duration} minutes\n` +
                      `Speakers: ${result.metadata?.speakers || 'Unknown'}\n` +
                      `Module: ${formDataObj.module || 'Not specified'}\n` +
                      `Meeting Type: ${formDataObj.meetingType || 'Not specified'}\n` +
                      `${formDataObj.projectWeek ? `Project Week: ${formDataObj.projectWeek}\n` : ''}` +
                      `\n📝 Complete Summary:\n${result.finalSummary}\n\n` +
                      `🎯 Decisions & Knowledge:\n${decisionsText}\n\n` +
                      `🎬 Actions:\n${result.actions?.join('\n') || 'None'}\n\n` +
                      `💡 Strategic Reasoning:\n${result.reasoning || 'None'}\n\n` +
                      `📚 Suggestions:\n${result.suggestions?.join('\n') || 'None'}`;
          
          // 保存最终总结
          await saveFinalSummary({
        ...result,
        context: formDataObj // 保存上下文供后续参考
      });
    
       
      console.log('✅ Final summary with context completed successfully');
      
    } else {
      console.error('❌ Final processing failed:', result.error);
      textArea.value = `❌ Final processing failed: ${result.error || 'Unknown error'}\n\n` +
                      'Please try again or contact support if the issue persists.';
    }
    
  } catch (err) {
    console.error('❌ Final processing failed:', err);
    textArea.value += '\n\n❌ Final processing failed. Please check your connection and try again.';
  }
}
    // ========== 保存函数（保持原有逻辑） ==========
    async function saveIntermediateSummary(summary) {
      try {
        await fetch('https://fyp-2025-kath.vercel.app/api/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            session: sessionId,
            transcript: transcriptChunks.join('\n'),
            summary: summary.summary,
            decision: summary.decision,
            explicit: summary.explicit,
            tacit: summary.tacit,
            reasoning: summary.reasoning,
            suggestions: summary.suggestions,
            is_intermediate: true,
            segment_number: segmentCount  // ✅ 修正字段名：segment_count → segment_number
          })
        });
      } catch (err) {
        console.error('Failed to save intermediate:', err);
      }
    }

    async function saveFinalSummary(result) {
  try {
    const saveData = {
      session: sessionId,
      transcript: result.fullTranscript || '',
      summary: result.finalSummary || '',
      decision: result.decisions || [],
      explicit: result.explicit || [],
      tacit: result.tacit || [],
      reasoning: result.reasoning || '',
      suggestions: result.suggestions || [],
      is_final: true,
      metadata: {
        ...result.metadata,
        context: result.context // 保存表单上下文
      }
    };
    
    const saveRes = await fetch('https://fyp-2025-kath.vercel.app/api/save', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(saveData)
    });
    
    if (saveRes.ok) {
      console.log('✅ Final summary saved to database');
    } else {
      console.warn('⚠️ Failed to save final summary');
    }
  } catch (err) {
    console.error('Error saving final summary:', err);
  }
}

    // ========== UI辅助函数 ==========
    function resetUI() {
      startBtn.disabled = false;
      stopBtn.disabled = true;
      recordingStatus.textContent = '';
      segmentStatus.textContent = '';
      
      // 停止所有流
      if (segmentStream) {
        segmentStream.getTracks().forEach(track => track.stop());
      }
      if (fullStream) {
        fullStream.getTracks().forEach(track => track.stop());
      }
    }
  </script>
</body>
</html>