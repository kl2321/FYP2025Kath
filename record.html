<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <style>
    body { font-family: sans-serif; padding: 16px; }
    button { padding: 8px 16px; margin-right: 8px; }
    textarea { width: 100%; height: 200px; margin-top: 12px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h2>üéôÔ∏è Record Meeting</h2>
  <button id="startBtn">Start</button>
  <button id="stopBtn" disabled>Stop</button>
  

  <textarea id="textArea" placeholder="Transcript and summary will appear here..."></textarea>

  <script>

    let totalSeconds = 0;
    let sessionStartTime = null;

    const fullTranscriptHistory =[];


    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const textArea = document.getElementById('textArea');
    

    let recorder;
    let chunks = [];

    const transcriptChunks = [];
    let recordingCycleCount = 0;
    let MAX_CYCLE = 10; // 30s * 10 = 5min
    let isManuallyStopped = false;
    let previousSummary = ''; // record last summary looop

    const urlParams = new URLSearchParams(window.location.search);
    const sessionId = urlParams.get("session");
    const autoStart = urlParams.get("start") === "true";

    console.log("üìé Extracted sessionId:", sessionId);

    

    startBtn.onclick = () => {
      transcriptChunks.length = 0;
      sessionStartTime = Date.now();
      totalSeconds = 0;
      startSegmentRecording();
    };
    
    stopBtn.onclick = () => {
      isManuallyStopped = true;
      stopRecording();
    };

  

   async function startSegmentRecording() {
    if (isManuallyStopped) {
      console.log("üõë Manually stopped, summarizing...");
      //console.log("üéØ isManuallyStopped:", isManuallyStopped);
      await summarizeChunks();
      return;
    }

    if (recordingCycleCount >= MAX_CYCLE) {
      console.log("‚è∞ Reached minute limit. Summarizing and continuing...")
      await summarizeChunks();
      recordingCycleCount =0;
      transcriptChunks.length =0;
      if (!isManuallyStopped) {
        startSegmentRecording();
      }
      return;
    }
    await startRecording();
    setTimeout(() => {
      if (!isManuallyStopped) {
        stopRecording();
      }
    }, 30000); // every 30s
  }  
    
    
    async function startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        recorder = new MediaRecorder(stream);
        //recorder.start();
        chunks = [];

        recorder.ondataavailable = (e) => chunks.push(e.data);

        recorder.onstop = async () => {
          console.log(" Recording stopped");
          console.log("üéØ isManuallyStopped:", isManuallyStopped);
          await handleSegmentAnalysis();
           if (isManuallyStopped) {
            await finalSummarize(); // ‚¨ÖÔ∏è ÊâãÂä®ÂÅúÊ≠¢Êó∂ÂÅöÊúÄÁªàÊÄªÁªì
          } else if (recordingCycleCount >= MAX_CYCLE) {
            await summarizeChunks(); // ‚¨ÖÔ∏è Ëá™Âä®ÊØè 1-5 ÂàÜÈíüÊÄªÁªì
          } else {
            startSegmentRecording(); // ‚¨ÖÔ∏è Âê¶ÂàôÁªßÁª≠
          }
          // if (isManuallyStopped || recordingCycleCount >= MAX_CYCLE) {
          //   await summarizeChunks();
          // } else {
          //   startSegmentRecording();
          // }
        };
        recorder.start();
        textArea.value = 'üéôÔ∏è Recording...';
        startBtn.disabled = true;
        stopBtn.disabled = false;
      } catch (err) {
    console.error('‚ùå Microphone error:', err);
    textArea.value = '‚ùå Microphone access denied.';
  }
}


      function stopRecording() {
       // isManuallyStopped = true;
       console.log("üìç stopRecording() called");
       console.log("‚õî isManuallyStopped:", isManuallyStopped);

        if (recorder && recorder.state === 'recording') {
          recorder.stop();
        } else if (recordingCycleCount > 0) {
          summarizeChunks();
        }
      }

      async function handleSegmentAnalysis() {
        const blob = new Blob(chunks, { type: 'audio/webm' });
        if (blob.size === 0) {
          textArea.value = '‚ùå No audio recorded.';
          return;
        }

        textArea.value = 'üîÑ Uploading and analyzing...';

        const form = new FormData();
        form.append('file', blob, 'audio.webm');

        try {
          const res = await fetch('https://fyp-2025-kath.vercel.app/api/analyze', {
            method: 'POST',
            body: form
          });

           const result = await res.json();
          console.log("‚úÖ Analysis result:", result);

          transcriptChunks.push(result.transcript || '');
          recordingCycleCount++;

          const durationMin = Math.floor((Date.now() - sessionStartTime) / 60000);
          textArea.value = `‚è±Ô∏è Total time: ${durationMin} min\n‚úÖ Segment ${recordingCycleCount} done`;
        } catch (err) {
          console.error('‚ùå Analysis failed:', err);
          textArea.value = '‚ùå Failed to analyze this chunk.';
        }
      }

      async function finalSummarize() {
        const fullTranscript = fullTranscriptHistory.join('\n');
        const duration = Math.floor((Date.now() - sessionStartTime) / 60000);
        textArea.value = `üì¶ Finalizing full content... (${duration} min)`;

        try {
          const res = await fetch('https://fyp-2025-kath.vercel.app/api/summarize', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: fullTranscript })
          });
          const data = await res.json();

          textArea.value = `‚è±Ô∏è Final transcript:\n${fullTranscript}\n\nüß† Final Summary:\n${data.summary}`;

          await fetch('https://fyp-2025-kath.vercel.app/api/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              session: sessionId,
              transcript: fullTranscript,
              summary: data.summary,
              is_final: true // optional field
            })
          });
          console.log("‚úÖ Final summary saved.");
        } catch (err) {
          console.error('‚ùå Final summary failed:', err);
          textArea.value = '‚ùå Final summary failed.';
        }
      }
            
      
      async function summarizeChunks() {
        const currentCombined = transcriptChunks.join('\n');
        fullTranscriptHistory.push(currentCombined);
        const combined = fullTranscriptHistory.join('\n');
        const duration = Math.floor((Date.now() - sessionStartTime) / 60000);
        textArea.value = `üß† Summarizing full content... (${duration} min)`;

        try {
          console.log("üì§ Sending to summarizer:", {
          text: combined,
          avoid: previousSummary
        });
            const res = await fetch('https://fyp-2025-kath.vercel.app/api/summarize', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              text: combined,
              avoid: previousSummary })
          });
          const data = await res.json();
          const summary = data.summary || '';

          if (!data.summary) {
            console.warn("‚õî No summary returned from OpenAI. Skipping save.");
            textArea.value = '‚ö†Ô∏è Summary failed. Skipped this round.';
            return;
          }
          // const summary = data.summary || '';
          //const transcript = data.transcript || combined;
          
          const transcript = combined;
          previousSummary = summary;
          console.log("üß†  transcript sent to summarizer:\n", combined);


          textArea.value = `‚è±Ô∏è ${duration} min transcript:\n${transcript}\n\nüß† Summary:\n${summary}`;

          
          // save to Supabase
          const saveRes = await fetch('https://fyp-2025-kath.vercel.app/api/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              session: sessionId,
              transcript,
              summary
            })
          });

          if (!saveRes.ok) {
            const errText = await saveRes.text();
            console.error("‚ùå Save to Supabase failed:", errText);
          } else {
            console.log("üì¶ Full result saved.");
          }   

          //console.log("üì¶ Full result saved.");

          // begin the next 5mins loop
          if (!isManuallyStopped) {
            console.log("üîÅ Restarting next 5-minute cycle...");
            recordingCycleCount = 0;
            transcriptChunks.length = 0;
            startSegmentRecording(); // ‚úÖ ÁªßÁª≠Âæ™ÁéØ
          }
        } catch (err) {
          console.error("‚ùå Error in summarizeChunks:", err);
          textArea.value = '‚ùå Error during summarizing or saving.';
        }

        startBtn.disabled = false;
        stopBtn.disabled = true;
      }

    function pollStop(sessionId) {
      console.log("üîÅ Starting pollStop for sessionId:", sessionId);
      const interval = setInterval(async () => {
        const url = `https://cwhekhkphzcovivgqezd.supabase.co/rest/v1/control_signals?session_id=eq.${sessionId}&command=eq.stop`;

        try {
          const res = await fetch(url, {
            headers: {
              'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN3aGVraGtwaHpjb3ZpdmdxZXpkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc5NjgyNjgsImV4cCI6MjA2MzU0NDI2OH0.hmZt6bFgKSWel6HiXfEjmm85P_j8fcsUo71hVWmkF2A',
              'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN3aGVraGtwaHpjb3ZpdmdxZXpkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc5NjgyNjgsImV4cCI6MjA2MzU0NDI2OH0.hmZt6bFgKSWel6HiXfEjmm85P_j8fcsUo71hVWmkF2A',
              'Content-Type': 'application/json'
            }
          });

          if (!res.ok) {
            const error = await res.text();
            console.error("‚ùå Supabase fetch failed:", error);
            return;
          }

          const data = await res.json();
          console.log("üì° poll result:", data);

          if (Array.isArray(data) && data.length > 0) {
            clearInterval(interval);
            console.log("üõë Stop command received. Stopping recorder...");
            isManuallyStopped = true; 
            stopRecording();
          }
        } catch (err) {
          console.error("‚ùå Polling error:", err);
        }
      }, 1000);
    }
    if (sessionId) {
      pollStop(sessionId);
  }

  window.onload = () => {
    window.opener?.postMessage({ type: 'ready-to-record' }, '*');
    console.log("üì§ record.html sent ready-to-record");

    if (autoStart) {
        console.log("‚öôÔ∏è Auto-start triggered");
        //isManuallyStopped = false;
        startBtn.click();
    }

  };
    // ‚úÖ Â§ñÈÉ®ÊéßÂà∂ÁöÑÁõëÂê¨Âô®Ôºàui.html ÂèëÈÄÅ postMessage ÊéßÂà∂Ôºâ
  window.addEventListener('message', (event) => {
    const { type, value } = event.data;
    if (type === 'start-recording') startBtn.click();
    if (type === 'stop-recording') stopBtn.click(); 
    if (type === 'set-max-cycle') {
      console.log("üõ†Ô∏è Setting MAX_CYCLE to:", value);
      if (typeof value === 'number' && value > 0) {
        MAX_CYCLE = Math.round((value * 60)/30);
        console.log("‚è±Ô∏è MAX_CYCLE set to:", MAX_CYCLE);
      } else {
        console.warn("‚ö†Ô∏è Invalid interval input:", value);
      }
    }
     
  });

 
  
  </script>
</body>
</html>

