<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Meeting Assistant</title>
  <style>
    /* [ä¿æŒåŸæœ‰çš„æ‰€æœ‰CSSæ ·å¼ä¸å˜] */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #ffffff;
      color: #333;
      padding: 0;
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Progress Indicator */
    .progress-bar {
      display: flex;
      justify-content: space-between;
      padding: 20px 24px;
      background: #f7f7f7;
      border-bottom: 1px solid #e5e5e5;
    }

    .progress-step {
      flex: 1;
      text-align: center;
      position: relative;
    }

    .progress-step::after {
      content: '';
      position: absolute;
      top: 15px;
      right: -50%;
      width: 100%;
      height: 2px;
      background: #e5e5e5;
      z-index: 0;
    }

    .progress-step:last-child::after {
      display: none;
    }

    .step-circle {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #e5e5e5;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: #999;
      position: relative;
      z-index: 1;
      transition: all 0.3s ease;
    }

    .progress-step.active .step-circle {
      background: #5E5CE6;
      color: white;
    }

    .progress-step.completed .step-circle {
      background: #30D158;
      color: white;
    }

    .step-label {
      margin-top: 8px;
      font-size: 11px;
      color: #666;
      font-weight: 500;
    }

    .progress-step.active .step-label {
      color: #5E5CE6;
      font-weight: 600;
    }

    /* Page Container */
    .page-container {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
    }
    .page-container .page#page4 {
  padding: 12px;  /* æ›´ç´§å‡‘çš„å†…è¾¹è· */
}

    .page {
      display: none;
      animation: fadeIn 0.3s ease;
    }

    .page.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Form Elements */
    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }

    input[type="text"],
    input[type="email"],
    select,
    textarea {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #d1d1d1;
      border-radius: 6px;
      font-size: 13px;
      transition: all 0.2s;
      background: white;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: #5E5CE6;
      box-shadow: 0 0 0 3px rgba(94, 92, 230, 0.1);
    }

    textarea {
      resize: vertical;
      min-height: 80px;
      font-family: inherit;
    }

    /* Radio/Checkbox Groups */
    .radio-group,
    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .radio-item,
    .checkbox-item {
      display: flex;
      align-items: center;
      padding: 12px;
      border: 1px solid #e5e5e5;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .radio-item:hover,
    .checkbox-item:hover {
      background: #f7f7f7;
      border-color: #5E5CE6;
    }

    .radio-item input[type="radio"],
    .checkbox-item input[type="checkbox"] {
      margin-right: 10px;
      cursor: pointer;
    }

    .radio-item.selected,
    .checkbox-item.selected {
      background: #F0F0FF;
      border-color: #5E5CE6;
    }

    /* File Upload Area */
    .upload-area {
      border: 2px dashed #d1d1d1;
      border-radius: 8px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      background: #fafafa;
    }

    .upload-area:hover {
      border-color: #5E5CE6;
      background: #F0F0FF;
    }

    .upload-area.dragover {
      border-color: #5E5CE6;
      background: #F0F0FF;
      transform: scale(1.02);
    }

    .upload-icon {
      font-size: 48px;
      color: #999;
      margin-bottom: 10px;
    }

    .upload-text {
      color: #666;
      font-size: 14px;
      margin-bottom: 8px;
    }

    .upload-hint {
      color: #999;
      font-size: 12px;
    }

    .file-list {
      margin-top: 16px;
    }

    .file-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: #f7f7f7;
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .file-name {
      font-size: 13px;
      color: #333;
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .file-remove {
      color: #999;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .file-remove:hover {
      background: #e5e5e5;
      color: #ff3b30;
    }

    /* Recording Interface */
    .recording-interface {
      text-align: center;
      padding: 40px 20px;
    }

    

    .record-button {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: linear-gradient(135deg, #FF3B30 0%, #FF6B6B 100%);
      border: none;
      color: white;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 20px rgba(255, 59, 48, 0.3);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .record-button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 30px rgba(255, 59, 48, 0.4);
    }

    .record-button.recording {
      background: linear-gradient(135deg, #666 0%, #999 100%);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 4px 20px rgba(255, 59, 48, 0.3); }
      50% { box-shadow: 0 4px 40px rgba(255, 59, 48, 0.6); }
      100% { box-shadow: 0 4px 20px rgba(255, 59, 48, 0.3); }
    }

    .recording-time {
      margin-top: 20px;
      font-size: 24px;
      font-weight: 300;
      color: #333;
      font-variant-numeric: tabular-nums;
    }

    .recording-status {
      margin-top: 10px;
      font-size: 14px;
      color: #666;
    }

    /* Navigation Buttons */
    .navigation {
      display: flex;
      justify-content: space-between;
      padding: 20px 24px;
      border-top: 1px solid #e5e5e5;
      background: #fafafa;
    }

    .btn {
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
    }

    .btn-secondary {
      background: white;
      color: #666;
      border: 1px solid #d1d1d1;
    }

    .btn-secondary:hover {
      background: #f7f7f7;
      border-color: #999;
    }

    .btn-primary {
      background: #5E5CE6;
      color: white;
    }

    .btn-primary:hover {
      background: #4B49D8;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(94, 92, 230, 0.3);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Success/Info Messages */
    .info-message {
      padding: 12px 16px;
      border-radius: 6px;
      margin-bottom: 20px;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .info-message.success {
      background: #E8F5E9;
      color: #2E7D32;
      border: 1px solid #A5D6A7;
    }

    .info-message.info {
      background: #E3F2FD;
      color: #1565C0;
      border: 1px solid #90CAF9;
    }

    .info-message.warning {
      background: #FFF3E0;
      color: #EF6C00;
      border: 1px solid #FFB74D;
    }

    .option-card {
  border: 1px solid #e5e5e5;
  border-radius: 8px;
  padding: 15px;
  margin: 10px 0;
}

.option-card h4 {
  margin-top: 0;
  color: #333;
}

/* Summary Page Styles - ä¼˜åŒ–ç‰ˆ */
.stats-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;  /* ä»16pxå‡å°‘åˆ°12px */
  margin-bottom: 16px;  /* ä»24pxå‡å°‘åˆ°16px */
}

.stat-card {
  background: #f8f9fa;
  border-radius: 10px;  /* ç¨å¾®å‡å°åœ†è§’ */
  padding: 16px;  /* ä»20pxå‡å°‘åˆ°16px */
  text-align: center;
  transition: transform 0.2s;
  border: 1px solid #e5e5e5;
}

.stat-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.08);
}

.stat-number {
  font-size: 36px;  /* ä»48pxå‡å°‘åˆ°36px */
  font-weight: bold;
  color: #5E5CE6;
  margin: 8px 0;  /* ä»10pxå‡å°‘åˆ°8px */
  line-height: 1;
}

.stat-label {
  font-size: 12px;  /* ä»14pxå‡å°‘åˆ°12px */
  color: #666;
  text-transform: uppercase;
  letter-spacing: 0.3px;  /* ç¨å¾®å‡å°å­—é—´è· */
  line-height: 1.2;
}

.stat-icon {
  font-size: 28px;  /* ä»32pxå‡å°‘åˆ°28px */
  margin-bottom: 6px;  /* ä»8pxå‡å°‘åˆ°6px */
}

/* Page 4ç‰¹å®šçš„å®¹å™¨æ ·å¼ */
#page4 {
  padding: 16px;  /* æ·»åŠ æ•´ä½“é¡µé¢å†…è¾¹è· */
}

#page4 h2 {
  margin-bottom: 16px;  /* å‡å°æ ‡é¢˜ä¸‹æ–¹é—´è· */
  font-size: 20px;  /* ç¨å¾®å‡å°æ ‡é¢˜å¤§å° */
}

.reminder-box {
  background: linear-gradient(135deg, #fff3cd 0%, #ffeeba 100%);
  border-left: 4px solid #ffc107;
  border-radius: 8px;
  padding: 12px 16px;  /* å‡å°‘padding */
  margin: 16px 0;  /* å‡å°‘margin */
  display: flex;
  align-items: center;
  gap: 12px;  /* å‡å°‘gap */
}

.reminder-icon {
  font-size: 24px;  /* ä»32pxå‡å°‘åˆ°24px */
}

.reminder-content h3 {
  margin: 0 0 2px 0;  /* å‡å°‘åº•éƒ¨margin */
  color: #856404;
  font-size: 14px;  /* ä»16pxå‡å°‘åˆ°14px */
}

.reminder-content p {
  margin: 0;
  color: #856404;
  font-size: 12px;  /* ä»14pxå‡å°‘åˆ°12px */
}

.progress-timer {
  margin-top: 20px;  /* ä»32pxå‡å°‘åˆ°20px */
  padding: 0 16px;  /* ä»20pxå‡å°‘åˆ°16px */
}

.timer-label {
  display: flex;
  justify-content: space-between;
  margin-bottom: 6px;  /* ä»8pxå‡å°‘åˆ°6px */
  font-size: 13px;  /* ä»14pxå‡å°‘åˆ°13px */
  color: #666;
}

.timer-bar {
  height: 6px;  /* ä»8pxå‡å°‘åˆ°6px */
  background: #e5e5e5;
  border-radius: 3px;
  overflow: hidden;
  position: relative;
}

.summary-sections {
  margin-top: 20px;  /* ä»32pxå‡å°‘åˆ°20px */
}

.summary-section {
  background: white;
  border: 1px solid #e5e5e5;
  border-radius: 8px;
  padding: 16px;  /* ä»20pxå‡å°‘åˆ°16px */
  margin-bottom: 12px;  /* ä»16pxå‡å°‘åˆ°12px */
}

.summary-section h3 {
  margin: 0 0 8px 0;  /* å‡å°‘åº•éƒ¨margin */
  color: #333;
  font-size: 14px;  /* ä»16pxå‡å°‘åˆ°14px */
  display: flex;
  align-items: center;
  gap: 6px;
}

.summary-content {
  color: #666;
  font-size: 13px;  /* ä»14pxå‡å°‘åˆ°13px */
  line-height: 1.5;  /* ç¨å¾®å‡å°è¡Œé«˜ */
}

.action-buttons {
  display: flex;
  gap: 10px;  /* ä»12pxå‡å°‘åˆ°10px */
  justify-content: center;
  margin-top: 20px;  /* ä»32pxå‡å°‘åˆ°20px */
  padding-bottom: 16px;  /* æ·»åŠ åº•éƒ¨padding */
}

.recording-status-box {
  background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
  border-left: 4px solid #4caf50;
  border-radius: 8px;
  padding: 12px 16px;
  margin: 16px 0;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.status-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  font-size: 14px;
  color: #2e7d32;
}

.recording-dot {
  width: 12px;
  height: 12px;
  background: #f44336;
  border-radius: 50%;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

.status-info {
  font-size: 12px;
  color: #2e7d32;
}

.status-info strong {
  font-weight: 600;
}

/* é’ˆå¯¹Figmaæ’ä»¶çš„ç‰¹æ®Šä¼˜åŒ– */
@media (max-height: 600px) {
  .stat-number {
    font-size: 32px;
  }
  .stat-icon {
    font-size: 24px;
  }
  .stats-container {
    gap: 8px;
  }
}


  </style>
</head>
<body>
  <!-- Progress Bar -->
  <div class="progress-bar">
    <div class="progress-step active" data-step="1">
      <div class="step-circle">1</div>
      <div class="step-label">Basic Info</div>
    </div>
    <div class="progress-step" data-step="2">
      <div class="step-circle">2</div>
      <div class="step-label">Meeting Setup</div>
    </div>
    <div class="progress-step" data-step="3">
      <div class="step-circle">3</div>
      <div class="step-label">Recording</div>
    </div>
    <div class="progress-step" data-step="4">
      <div class="step-circle">4</div>
      <div class="step-label">Summary</div>
    </div>
  </div>

  <!-- Page Container -->
  <div class="page-container">
    <!-- Page 1: Basic Information -->
    <div class="page active" id="page1">
      <h2 style="margin-bottom: 24px;">Meeting Configuration</h2>
      
      <div class="form-group">
        <label>Your Role *</label>
        <div class="radio-group">
          <div class="radio-item">
            <input type="radio" id="student" name="role" value="student" checked>
            <label for="student" style="margin: 0;">Student</label>
          </div>
          <div class="radio-item">
            <input type="radio" id="tutor" name="role" value="tutor/instructor">
            <label for="tutor" style="margin: 0;">Tutor/Instructor</label>
          </div>
        </div>
      </div>

      <div class="form-group">
        <label for="module">Course Module *</label>
        <select id="module" required>
          <option value="">Select a module...</option>
          <option value="DE4 ERO">DE4 ERO</option>
          <option value="IDE2 TTL">IDE2 TTL</option>
          <option value="DE3 Futures ">DE3 Futures</option>
          <option value="DE3 I&E">DE3 I&E</option>
          <option value="xxx">xxx</option>
        </select>
      </div>


      <div class="form-group">
        <label for="team-name">Group Name/Number (optional)</label>
        <input type="text" id="team-name" placeholder="Enter your group name/number">
        <small style="color: #999; font-size: 11px; margin-top: 4px; display: block;">
        </small>
      </div>

      <div class="form-group">
        <label for="project-status">Project Status *</label>
        <input type="text" id="project-status" placeholder="Enter project week number (e.g. Week 1, Week 2)">
        <small style="color: #999; font-size: 11px; margin-top: 4px; display: block;">
          Helps to improve analysis and tailored suggestions.
        </small>
      </div>

      <div class="form-group">
        <label for="meeting-type">Meeting Type *</label>
        <select id="meeting-type" required>
          <option value="">Select meeting type...</option>
          <option value="brainstorming">Brainstorming Session</option>
          <option value="project-planning">Project Planning</option>
          <!-- <option value="progress-update">Progress Update</option> -->
          <option value="problem-solving">Problem Solving</option>
          <!-- <option value="retrospective">Retrospective</option> -->
        </select>
      </div>

      

      <div class="form-group">
        <label for="team-members">Team Members (optional)</label>
        <input type="text" id="team-members" placeholder="Enter names separated by commas">
        <small style="color: #999; font-size: 11px; margin-top: 4px; display: block;">
          This helps with speaker identification
        </small>
      </div>

      <div class="form-group">
        <label for="meeting-goals">Meeting Goals (optional)</label>
        <textarea id="meeting-goals" placeholder="What do you hope to achieve in this meeting?"></textarea>
      </div>
    </div>

    <!-- Page 2: File Upload & Settings -->
    <div class="page" id="page2">
      <h2 style="margin-bottom: 24px;">Upload Supporting Materials</h2>
      
      <div class="info-message info">
        <span>ğŸ’¡</span>
        <span>Upload any relevant documents to provide context for better AI analysis</span>
      </div>

      <div class="form-group">
        <label>Supporting Documents (optional)</label>
        <div class="upload-area" id="uploadArea">
          <div class="upload-icon">ğŸ“</div>
          <div class="upload-text">Click to upload or drag and drop</div>
          <div class="upload-hint">PDF, DOC, DOCX, TXT, Images (Max 10MB)</div>
          <input type="file" id="fileInput" multiple accept=".pdf,.doc,.docx,.txt,.png,.jpg,.jpeg" style="display: none;">
        </div>
        <div class="file-list" id="fileList"></div>
      </div>

      <!-- NEW: Previous Meeting Minutes Section -->
  <div class="form-group">
    <label for="previous-summary">Previous Meeting Summary *</label>
    <textarea 
      id="previous-summary" 
      placeholder="Paste your previous meeting minutes here for context and continuity (required)..."
      style="min-height: 120px; font-family: inherit; line-height: 1.5;"
      required
    ></textarea>
    <small style="color: #999; font-size: 11px; margin-top: 4px; display: block;">
      <strong>Required:</strong> Including previous minutes helps AI provide better follow-up analysis and track progress
    </small>
  </div>

   <div class="form-group">
    <label>Analysis Preferences</label>
    <div class="checkbox-group">
      <!-- Existing checkboxes remain unchanged -->
      <div class="checkbox-item">
        <input type="checkbox" id="key-decisions" checked>
        <label for="key-decisions" style="margin: 0;">Extract Key Decisions</label>
      </div>
      <div class="checkbox-item">
        <input type="checkbox" id="action-items" checked>
        <label for="action-items" style="margin: 0;">Identify Action Items</label>
      </div>
      <div class="checkbox-item">
        <input type="checkbox" id="speaker-analysis">
        <label for="speaker-analysis" style="margin: 0;">Analyze Speaker Contributions</label>
      </div>
      <div class="checkbox-item">
        <input type="checkbox" id="progress-tracking">
        <label for="progress-tracking" style="margin: 0;">Track the Project Progress</label>
      </div>


      
        </div>
      </div>
    </div>

    <!-- Page 3: Recording -->
<div class="page" id="page3">
  <h2 style="margin-bottom: 24px;">Start Recording</h2>

  <div id="recording-interface"></div>
    
    <!-- æ·»åŠ å½•éŸ³é—´éš”è®¾ç½® -->
    <div style="margin-top: 30px;">
      <label for="cycleInput">Summary interval (minutes):</label>
      <input id="cycleInput" type="number" value="5" min="1" max="30" 
             style="width: 80px; padding: 8px; margin-left: 10px;">
    </div>
    
    <div style="margin-top: 40px;">
      <div class="info-message info" style="text-align: left;">
        <span>â„¹ï¸</span>
        <div>
          <strong>Recording Instructions:</strong><br>
          â€¢ A new window will open for recording<br>
          â€¢ Allow microphone access when prompted<br>  
          â€¢ Recording will auto-save every 5 minutes<br>
          â€¢ You can stop recording from this page
        </div>
      </div>
    </div>
  </div>
  
  <!-- æ·»åŠ åœæ­¢æŒ‰é’®ï¼ˆåˆå§‹éšè—ï¼‰ -->
  <div style="text-align: center; margin-top: 20px;">
    <button class="btn btn-secondary" id="stopRecordingBtn" style="display: none;">
      Stop Recording
    </button>
  </div>
</div>

<!-- æ·»åŠ æŸ¥çœ‹æ‘˜è¦æŒ‰é’® -->
<!-- <div style="text-align: center; margin-top: 20px;">
  <button class="btn btn-primary" id="viewSummaryBtn" onclick="goToSummaryPage()" style="display: none;">
    View Summary Demo
  </button>

<div style="text-align: center; margin-top: 20px;">
    <button class="btn btn-primary" onclick="testRealtimeAnalysis()" 
            style="background: #ff9800; border-color: #ff9800;">
      ğŸ§ª Test Realtime Analysis (Dev Only)
    </button>
  </div> -->
<!-- Navigation Buttons -->
  <div class="navigation">
    <button class="btn btn-secondary" id="prevBtn" onclick="changePage(-1)">Previous</button>
    <button class="btn btn-primary" id="nextBtn" onclick="changePage(1)">Next</button>
  </div>
  <!-- ç´§æ¥ç€æ·»åŠ  script -->
<script>
function testRealtimeAnalysis() {
  console.log('ğŸ§ª Testing from inline script...');
  
  // å¦‚æœ callRealtimeSummarize ä¸å¯ç”¨ï¼Œå°è¯•ç›´æ¥è°ƒç”¨ API
  if (typeof callRealtimeSummarize === 'undefined') {
    console.log('âš ï¸ Using direct API call for testing');
    
    fetch('https://fyp-2025-kath.vercel.app/api/summarize', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: "Speaker A: We decided to use PostgreSQL.",
        avoid: "",
        session_id: null,
        form_data: {
          role: "student",
          module: "DE4 ERO",
          meetingType: "technical-review",
          projectWeek: "Week 5"
        }
      })
    })
    .then(r => r.json())
    .then(d => {
      console.log('âœ… API Response:', d);
      alert('Test successful! Check console for details.');
    })
    .catch(e => {
      console.error('âŒ Test failed:', e);
      alert('Test failed! Check console.');
    });
  } else {
    // ä½¿ç”¨å·²å®šä¹‰çš„å‡½æ•°
    callRealtimeSummarize("Test transcript", "");
  }
}
</script>

</div>

<!-- Page 4: Summary -->

<!-- Page 4: Real-time Progress Monitor -->
<div class="page" id="page4">
  <h2 style="margin-bottom: 24px;">ğŸ™ï¸ Recording Progress</h2>
  
  <!-- ç»Ÿè®¡å¡ç‰‡ - åªä¿ç•™4ä¸ª -->
  <div class="stats-container">
    <!-- å†³ç­–æ•°é‡ -->
    <div class="stat-card">
      <div class="stat-icon">ğŸ¯</div>
      <div class="stat-number" id="decisionsCount">0</div>
      <div class="stat-label">Decisions</div>
    </div>
    
    <!-- è¯´è¯äººæ•°é‡ -->
    <div class="stat-card">
      <div class="stat-icon">ğŸ‘¥</div>
      <div class="stat-number" id="speakersCount">0</div>
      <div class="stat-label">Speakers</div>
    </div>
    
    <!-- ä¼šè®®æ—¶é•¿ -->
    <div class="stat-card">
      <div class="stat-icon">â±ï¸</div>
      <div class="stat-number" id="durationDisplay">00:00</div>
      <div class="stat-label">Duration</div>
    </div>
    
    <!-- ä¸‹ä¸€æ¬¡åˆ†æ -->
    <div class="stat-card">
      <div class="stat-icon">â­ï¸</div>
      <div class="stat-number" id="nextSegmentTime">--:--</div>
      <div class="stat-label">Next Segment</div>
    </div>
  </div>
  
  <!-- æé†’æ¡† -->
  <div class="reminder-box">
    <div class="reminder-icon">â°</div>
    <div class="reminder-content">
      <h3>Next Analysis Segment</h3>
      <p id="segmentReminderText">Recording in progress. Next AI analysis in <strong id="segmentCountdown">--</strong></p>
    </div>
  </div>
  
  <!-- å½•éŸ³çŠ¶æ€ -->
  <div class="recording-status-box">
    <div class="status-indicator">
      <div class="recording-dot"></div>
      <span id="recordingStatusText">Recording...</span>
    </div>
    <div class="status-info">
      <p id="recordingInfoText">Meeting started at <strong id="startTimeDisplay">--:--</strong></p>
    </div>
  </div>
  
  <!-- æœ€æ–°å†³ç­– -->
  <div class="summary-sections">
    <div class="summary-section">
      <h3>ğŸ¯ Latest Decisions</h3>
      <div class="summary-content" id="latestDecisions">
        <em style="color: #999;">No decisions recorded yet. AI will analyze the discussion periodically.</em>
      </div>
    </div>
  </div>
  
  <!-- æŒ‰é’® -->
  <div class="action-buttons">
    <button class="btn btn-secondary" onclick="goBackToRecording()">â† Back to Recording</button>
    <button class="btn btn-primary" onclick="refreshProgress()">ğŸ”„ Refresh</button>
  </div>

    <!-- Navigation Buttons -->
  <div class="navigation">
    <button class="btn btn-secondary" id="prevBtn" onclick="changePage(-1)">Previous</button>
    <button class="btn btn-primary" id="nextBtn" onclick="changePage(1)">Next</button>
  </div>
</div>
   
  <script>
    // // ===== MODIFIED STORAGE SOLUTION FOR FIGMA PLUGIN =====
    // // Use in-memory storage and communicate with plugin for persistence
    
    // State Management (in-memory)
    let currentPage = 1;
    const totalPages = 4;
    let formData = {
      role: 'student',
      module: '',
      meetingType: '',
      teamMembers: [],
      meetingGoals: '',
      files: [],
      preferences: {
        keyDecisions: true,
        actionItems: true,
        speakerAnalysis: false,
        progressTracking: false
      },
      additionalContext: '',
      pdfText: '',
      pdfFileName: ''
    };

    // // Recording state
     let isRecording = false;
    // let recordingStartTime = null;
    // let recordingInterval = null;
    // let mediaRecorder = null;
    // let audioChunks = [];

    // ===== STORAGE FUNCTIONS (Modified for Figma) =====
    
    // Save data to plugin storage via postMessage
    function saveToPluginStorage(key, value) {
      parent.postMessage({
        pluginMessage: {
          type: 'save-storage',
          key: key,
          value: value
        }
      }, '*');
    }

    // Request data from plugin storage
    function loadFromPluginStorage(key) {
      parent.postMessage({
        pluginMessage: {
          type: 'load-storage',
          key: key
        }
      }, '*');
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      updatePageDisplay();
      setupEventListeners();
      // Request saved data from plugin
      loadFromPluginStorage('meetingFormData');
    });

    // Listen for messages from plugin
    window.onmessage = (event) => {
      const message = event.data.pluginMessage;
      if (!message) return;

      switch (message.type) {
        case 'storage-loaded':
          if (message.key === 'meetingFormData' && message.value) {
            formData = message.value;
            restoreFormFields();
          }
          break;
        case 'processing-complete':
          displaySummaryResults(message.results);
          break;
        case 'processing-error':
          showMessage(message.error, 'warning');
          break;
      }
    };

    // æ‰‹åŠ¨è·³è½¬åˆ°Summaryé¡µé¢ï¼ˆç”¨äºæµ‹è¯•ï¼‰
window.goToSummaryPage = function() {
  currentPage = 4;
  updatePageDisplay();
  displaySummaryResults(null); // æ˜¾ç¤ºdemoæ•°æ®
}

// åœ¨é¡µé¢åŠ è½½å®Œæˆåï¼Œä¸ºæµ‹è¯•æ·»åŠ ä¸€ä¸ªæŒ‰é’®
document.addEventListener('DOMContentLoaded', () => {
  // ... åŸæœ‰ä»£ç  ...
  
  // æ·»åŠ æµ‹è¯•æŒ‰é’®ï¼ˆå¯é€‰ï¼‰
  setTimeout(() => {
    const viewSummaryBtn = document.getElementById('viewSummaryBtn');
    if (viewSummaryBtn && currentPage === 3) {
      viewSummaryBtn.style.display = 'inline-block';
    }
  }, 1000);
});

    // Page Navigation
    function changePage(direction) {
      // Save current page data
      savePageData();

      // Validate before moving forward
      if (direction > 0 && !validateCurrentPage()) {
        showMessage('Please fill in all required fields', 'warning');
        return;
      }

      // Change page
      currentPage += direction;
      if (currentPage < 1) currentPage = 1;
      if (currentPage > totalPages) currentPage = totalPages;

      // Special handling for recording page
      if (currentPage === 3) {
        prepareRecordingPage();
      }

      // Update display
      updatePageDisplay();
      
      // Animate transition
      animatePageTransition();
    }

    function updatePageDisplay() {
      // Hide all pages
      document.querySelectorAll('.page').forEach(page => {
        page.classList.remove('active');
      });

      // Show current page
      document.getElementById(`page${currentPage}`).classList.add('active');

      // Update progress bar
      document.querySelectorAll('.progress-step').forEach((step, index) => {
        if (index < currentPage - 1) {
          step.classList.add('completed');
          step.classList.remove('active');
        } else if (index === currentPage - 1) {
          step.classList.add('active');
          step.classList.remove('completed');
        } else {
          step.classList.remove('active', 'completed');
        }
      });

      // Update navigation buttons
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');

      prevBtn.style.display = currentPage === 1 ? 'none' : 'block';
      
      if (currentPage === 3) {
        nextBtn.textContent = 'Finish Recording';
        nextBtn.style.display = isRecording ? 'block' : 'none';
      } else if (currentPage === 4) {
        nextBtn.style.display = 'none';
      } else {
        nextBtn.textContent = 'Next';
        nextBtn.style.display = 'block';
      }
    }

    function animatePageTransition() {
      const activePage = document.querySelector('.page.active');
      activePage.style.animation = 'none';
      setTimeout(() => {
        activePage.style.animation = 'fadeIn 0.3s ease';
      }, 10);
    }

    // Event Listeners Setup
    function setupEventListeners() {
      // File upload
      const uploadArea = document.getElementById('uploadArea');
      const fileInput = document.getElementById('fileInput');

      if (uploadArea && fileInput) {
        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
          e.preventDefault();
          uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
          uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
          e.preventDefault();
          uploadArea.classList.remove('dragover');
          handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
          handleFiles(e.target.files);
        });
      }

      // Radio buttons visual feedback
      document.querySelectorAll('.radio-item').forEach(item => {
        item.addEventListener('click', () => {
          document.querySelectorAll('.radio-item').forEach(i => i.classList.remove('selected'));
          item.classList.add('selected');
          item.querySelector('input[type="radio"]').checked = true;
        });
      });

      // Checkbox visual feedback
      document.querySelectorAll('.checkbox-item').forEach(item => {
        item.addEventListener('click', () => {
          const checkbox = item.querySelector('input[type="checkbox"]');
          checkbox.checked = !checkbox.checked;
          item.classList.toggle('selected', checkbox.checked);
        });
      });

      // Recording button
      const recordButton = document.getElementById('recordButton');
      if (recordButton) {
        recordButton.addEventListener('click', toggleRecording);
      }

      const stopBtn = document.getElementById('stopRecordingBtn');

       const stopRecordingBtn = document.getElementById('stopRecordingBtn');
  if (stopRecordingBtn) {
    stopRecordingBtn.addEventListener('click', () => {
      console.log('Stop button clicked');
      stopExternalRecording();  // è°ƒç”¨åœæ­¢å‡½æ•°
    });
  }

    }

    // File Handling
    // File Handling
async function handleFiles(files) {
  const fileList = document.getElementById('fileList');
  
  for (const file of Array.from(files)) {
    // Validate file
    if (file.size > 10 * 1024 * 1024) {
      showMessage(`File ${file.name} is too large (max 10MB)`, 'warning');
      continue;
    }

    // å¦‚æœæ˜¯PDFæ–‡ä»¶ï¼Œè¿›è¡Œç‰¹æ®Šå¤„ç†
    if (file.type === 'application/pdf') {
      console.log('ğŸ“„ Processing PDF file:', file.name);
      
      // ä¿å­˜æ–‡ä»¶å
      formData.pdfFileName = file.name;
      
      // ä½¿ç”¨æœåŠ¡å™¨ç«¯PDFå¤„ç†
      try {
        showMessage('Processing PDF...', 'info');
        
        const pdfFormData = new FormData();
        pdfFormData.append('file', file);
        
        const response = await fetch(`${API_CONFIG.BASE_URL}/api/ingest_pdf`, {
          method: 'POST',
          body: pdfFormData
        });
        
        const result = await response.json();
        
        if (result?.text && result.text.length > 0) {
          formData.pdfText = result.text;
  formData.pdfFileName = file.name;  // ç¡®ä¿æ–‡ä»¶åä¹Ÿè¢«ä¿å­˜
  
  // æ·»åŠ è¿™äº›è°ƒè¯•æ—¥å¿—
  console.log('âœ… PDFå¤„ç†å®Œæˆ:');
  console.log('  - æ–‡ä»¶å:', formData.pdfFileName);
  console.log('  - æ–‡æœ¬é•¿åº¦:', formData.pdfText.length);
  console.log('  - å‰100å­—ç¬¦:', formData.pdfText.substring(0, 100));
          showMessage(`PDF processed: ${(result.text.length/1000).toFixed(1)}k characters`, 'success');
        } else {
          showMessage('Could not extract text from PDF', 'warning');
        }
      } catch (err) {
        console.error('PDF processing error:', err);
        showMessage('Failed to process PDF', 'warning');
      }
    }

    // Store file metadata
    formData.files.push({
      name: file.name,
      size: file.size,
      type: file.type
    });

    // Display file
    const fileItem = document.createElement('div');
    fileItem.className = 'file-item';
    fileItem.innerHTML = `
      <span class="file-name">${file.name}</span>
      <span class="file-remove" onclick="removeFile('${file.name}')">âœ•</span>
    `;
    fileList.appendChild(fileItem);

    // Send file info to plugin
    parent.postMessage({
      pluginMessage: {
        type: 'file-upload',
        fileName: file.name,
        fileType: file.type,
        fileSize: file.size
      }
    }, '*');
  }
}

// Make removeFile globally accessible
window.removeFile = function(fileName) {
  console.log('Removing file:', fileName);
  formData.files = formData.files.filter(f => f.name !== fileName);
  updateFileList();
  
  // å¦‚æœæ˜¯PDFæ–‡ä»¶ï¼Œæ¸…é™¤PDFæ–‡æœ¬
  if (fileName === formData.pdfFileName) {
    formData.pdfText = '';
    formData.pdfFileName = '';
    console.log('Cleared PDF text cache');
  }
}

// Update file list display
function updateFileList() {
  const fileList = document.getElementById('fileList');
  if (!fileList) {
    console.warn('fileList element not found');
    return;
  }
  
  fileList.innerHTML = '';
  
  if (!formData.files || formData.files.length === 0) {
    console.log('No files to display');
    return;
  }
  
  formData.files.forEach(file => {
    const fileItem = document.createElement('div');
    fileItem.className = 'file-item';
    fileItem.innerHTML = `
      <span class="file-name">${file.name}</span>
      <span class="file-remove" onclick="removeFile('${file.name}')">âœ•</span>
    `;
    fileList.appendChild(fileItem);
  });
  
  console.log(`Updated file list with ${formData.files.length} files`);
}
 

    // Recording Functions
    async function toggleRecording() {
      if (!isRecording) {
        await startRecording();
      } else {
        stopRecording();
      }
    }

    async function startRecording() {
      try {
        // Request microphone access
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Create MediaRecorder
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          audioChunks.push(event.data);
        };

        mediaRecorder.onstop = async () => {
          // Create audio blob
          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          
          // Process recording
          await processRecording(audioBlob);
        };

        // Start recording
        mediaRecorder.start();
        isRecording = true;
        recordingStartTime = Date.now();

        // Update UI
        document.getElementById('recordButton').classList.add('recording');
        document.getElementById('recordButtonText').textContent = 'Stop Recording';
        document.getElementById('recordingStatus').textContent = 'Recording in progress...';
        document.getElementById('nextBtn').style.display = 'block';

        // Start timer
        recordingInterval = setInterval(updateRecordingTime, 1000);

      } catch (error) {
        console.error('Error starting recording:', error);
        showMessage('Failed to access microphone. Please check permissions.', 'warning');
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
        
        // Stop all tracks
        mediaRecorder.stream.getTracks().forEach(track => track.stop());
        
        isRecording = false;
        clearInterval(recordingInterval);

        // Update UI
        document.getElementById('recordButton').classList.remove('recording');
        document.getElementById('recordButtonText').textContent = 'Processing...';
        document.getElementById('recordingStatus').textContent = 'Processing your recording...';
        document.getElementById('recordButton').disabled = true;
      }
    }

    // function updateRecordingTime() {
    //   const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
    //   const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
    //   const seconds = (elapsed % 60).toString().padStart(2, '0');
    //   document.getElementById('recordingTime').textContent = `${minutes}:${seconds}`;
    // }

    // async function processRecording(audioBlob) {
    //   // Move to summary page
    //   currentPage = 4;
    //   updatePageDisplay();

    //   // Convert blob to base64 for Figma plugin communication
    //   const reader = new FileReader();
    //   reader.onloadend = () => {
    //     parent.postMessage({
    //       pluginMessage: {
    //         type: 'process-recording',
    //         formData: formData,
    //         audioData: reader.result
    //       }
    //     }, '*');
    //   };
    //   reader.readAsDataURL(audioBlob);
    // }

    // Form Validation
    function validateCurrentPage() {
      if (currentPage === 1) {
        const module = document.getElementById('module').value;
        const meetingType = document.getElementById('meeting-type').value;
        
        if (!module || !meetingType) {
          return false;
        }
      }
      return true;
    }

    // Add validation in the savePageData function or before sending config
function validateProjectWeek(value) {
  if (!value) return '';
  
  // Ensure proper format: "Week X" or "Week X-Y"
  const trimmed = value.trim();
  
  // If user enters "RCA week 5" or similar, convert to "Week 5"
  if (trimmed.toLowerCase().includes('week')) {
    const match = trimmed.match(/week\s*(\d+(?:-\d+)?)/i);
    if (match) {
      return `Week ${match[1]}`;
    }
  }
  
  // If user just enters a number, format it properly
  if (/^\d+(?:-\d+)?$/.test(trimmed)) {
    return `Week ${trimmed}`;
  }
  
  return trimmed;
}


    // Data Persistence
    function savePageData() {
      if (currentPage === 1) {
        formData.role = document.querySelector('input[name="role"]:checked').value;
        formData.module = document.getElementById('module').value;
        formData.meetingType = document.getElementById('meeting-type').value;
        console.log('ğŸ’¾ ä¿å­˜Page1æ•°æ®:', {
        module: formData.module,
        meetingType: formData.meetingType,
        role: formData.role
        
      });
         const teamNameInput = document.getElementById('team-name');
    if (teamNameInput) {
      const teamInfo = teamNameInput.value.trim();
      // å°è¯•åˆ†ç¦» groupName å’Œ groupNumber
      if (teamInfo.match(/[A-Z]\d+/)) {
        formData.groupNumber = teamInfo.match(/[A-Z]\d+/)[0];
        formData.groupName = teamInfo.replace(/[A-Z]\d+/, '').trim();
      } else {
        formData.groupName = teamInfo;
      }
    }
    const projectStatus = document.getElementById('project-status');
    if (projectStatus) {
       formData.projectWeek = validateProjectWeek(projectStatus.value);
    }
        formData.teamMembers = document.getElementById('team-members').value.split(',').map(s => s.trim()).filter(Boolean);
        formData.meetingGoals = document.getElementById('meeting-goals').value;
      } else if (currentPage === 2) {
        formData.preferences.keyDecisions = document.getElementById('key-decisions').checked;
        formData.preferences.actionItems = document.getElementById('action-items').checked;
        formData.preferences.speakerAnalysis = document.getElementById('speaker-analysis').checked;
        formData.preferences.progressTracking = document.getElementById('progress-tracking').checked;

        const previousSummary = document.getElementById('previous-summary');
  if (previousSummary) {
    formData.previousSummary = previousSummary.value;
  }
      }

      // Save to plugin storage
      saveToPluginStorage('meetingFormData', formData);
    }

    // æ–°å¢ï¼šè°ƒç”¨å®æ—¶åˆ†æçš„å‡½æ•°
async function callRealtimeSummarize(transcript, previousSummary = '') {
  console.log('ğŸ¯ Calling realtime summarize API...');

  if (!formData.module || !formData.meetingType) {
    console.warn('âš ï¸ formDataç¼ºå¤±å¿…è¦å­—æ®µ');
    
    // å°è¯•ä»localStorageæ¢å¤
    const savedData = localStorage.getItem('meetingFormData');
    if (savedData) {
      try {
        const parsed = JSON.parse(savedData);
        formData = { ...formData, ...parsed };
      } catch (e) {
        console.error('Failed to parse saved data');
      }
    }
    
    // å¦‚æœè¿˜æ˜¯æ²¡æœ‰ï¼Œä½¿ç”¨é»˜è®¤å€¼
    if (!formData.module) formData.module = 'DE4 ERO';
    if (!formData.meetingType) formData.meetingType = 'brainstorming';
    formData.module = formData.module || 'DE4 ERO';
    formData.meetingType = formData.meetingType || 'brainstorming';
  }
  
  // æ”¶é›†è¡¨å•æ•°æ®
  const formDataForAPI = {
    role: formData.role || 'student',
    module: formData.module || 'DE4 ERO',
    meetingType: formData.meetingType || 'brainstorming',
    projectWeek: formData.projectWeek || '',
    groupName: formData.groupName || '',
    groupNumber: formData.groupNumber || '',
    meetingGoals: formData.meetingGoals || '',
    teamMembers: formData.teamMembers || []
  };
  
  try {
    const response = await fetch(`${API_CONFIG.BASE_URL}/api/summarize`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        text: transcript,
        avoid: previousSummary,
        session_id: recordingSessionId,
        form_data: formDataForAPI
      })
    });
    
    const result = await response.json();
    
    if (result.decisions && result.decisions.length > 0) {
      console.log('âœ… Found', result.decisions.length, 'decisions');
      // æ˜¾ç¤ºå†³ç­–
      displayRealtimeDecisions(result.decisions);
    }
    
    return result;
  } catch (error) {
    console.error('âŒ Realtime analysis error:', error);
    return null;
  }
}

// æ˜¾ç¤ºå®æ—¶å†³ç­–
function displayRealtimeDecisions(decisions) {

   console.log('ğŸ“Š Updating decisions:', decisions.length);
  
  // âœ¨ æ–°å¢ï¼šè®¡ç®—è¯´è¯äººæ•°é‡
  const speakers = new Set();
  decisions.forEach(d => {
    if (d.speaker) speakers.add(d.speaker);
    if (d.owner) speakers.add(d.owner);
  });
  const speakersCount = speakers.size || 0;
  
  // âœ¨ æ–°å¢ï¼šæ›´æ–° Page 4 æ•°æ®
  updateProgressStats(decisions.length, speakersCount);
  updateLatestDecisions(decisions);
  
  // æ›´æ–°å†³ç­–è®¡æ•°
  const decisionsCount = document.getElementById('decisionsCount');
  if (decisionsCount) {
    decisionsCount.textContent = decisions.length;
  }
  
  // æ›´æ–°å†³ç­–åˆ—è¡¨
  const keyDecisions = document.getElementById('keyDecisions');
  if (keyDecisions) {
    keyDecisions.innerHTML = decisions.map((d, i) => 
      `â€¢ Decision ${d.decision_number}: ${d.decision}<br>
       &nbsp;&nbsp;Explicit: ${d.explicit_knowledge.length} points<br>
       &nbsp;&nbsp;Tacit: ${d.tacit_knowledge.length} points`
    ).join('<br><br>');
  }

   window.__sentDecisionCount = window.__sentDecisionCount || 0;

  // è¿™æ¬¡ç›¸å¯¹ä¸Šæ¬¡â€œæ–°å¢â€çš„éƒ¨åˆ†
  const newlyAdded = decisions.slice(window.__sentDecisionCount);

  // é€æ¡å‘é€åˆ°æ’ä»¶ï¼ˆcode.ts é‡Œç”¨ update-realtime -> addDecision æ¸²æŸ“ï¼‰
  newlyAdded.forEach(d => {
    const decisionText = d.decision || d.text || '';
    const owner = d.speaker || d.owner || 'Unknown';

    parent.postMessage({
      pluginMessage: {
        type: 'add-decision',
        data: {
         //type: 'decision',
          text: decisionText,
          number: d.decision_number,
          //owner
        }
      }
    }, '*');
  });

  // æ›´æ–°ç´¯è®¡å·²å‘é€è®¡æ•°
  window.__sentDecisionCount = decisions.length;
}

    function restoreFormFields() {
      // Page 1 fields
      if (document.getElementById('module')) {
        document.getElementById('module').value = formData.module || '';
        document.getElementById('meeting-type').value = formData.meetingType || '';
        document.getElementById('team-members').value = formData.teamMembers.join(', ');
        document.getElementById('meeting-goals').value = formData.meetingGoals || '';
        
        // Radio buttons
        document.querySelector(`input[name="role"][value="${formData.role}"]`).checked = true;
      }

      // Page 2 fields
      if (document.getElementById('key-decisions')) {
        document.getElementById('key-decisions').checked = formData.preferences.keyDecisions;
        document.getElementById('action-items').checked = formData.preferences.actionItems;
        document.getElementById('speaker-analysis').checked = formData.preferences.speakerAnalysis;
        document.getElementById('progress-tracking').checked = formData.preferences.progressTracking;
      }

      // Update file list
      if (document.getElementById('fileList')) {
      updateFileList();
    }
  }

   function prepareRecordingPage() {
  // è·å–recording-interfaceå…ƒç´ ï¼ˆæ–°çš„å®¹å™¨ï¼‰
  const recordingInterface = document.getElementById('recording-interface');
  
  if (!recordingInterface) {
    console.warn('recording-interface element not found');
    // å¦‚æœæ–°å…ƒç´ ä¸å­˜åœ¨ï¼Œå°è¯•ä½¿ç”¨æ—§çš„ç»“æ„
    const readyMessage = document.getElementById('readyMessage');
    if (readyMessage) {
      // ä½¿ç”¨æ—§çš„æ–¹å¼
      let messageContent = `
        <span>âœ…</span>
        <div>
          <strong>Ready to record!</strong><br>
          Module: ${formData.module.replace('-', ' ')}<br>
          Meeting Type: ${formData.meetingType.replace('-', ' ')}<br>`;
      
      if (formData.files.length > 0) {
        messageContent += `${formData.files.length} supporting file(s) uploaded<br>`;
      }
      
      if (formData.pdfText && formData.pdfText.length > 0) {
        messageContent += `ğŸ“„ PDF loaded: ${(formData.pdfText.length/1000).toFixed(1)}k characters<br>`;
      }
      
      messageContent += `</div>`;
      readyMessage.innerHTML = messageContent;
    }
    return;
  }
  
  // ä½¿ç”¨æ–°çš„ç•Œé¢ï¼ˆæš‚æ—¶æ˜¾ç¤ºç®€å•ä¿¡æ¯ï¼‰
  recordingInterface.innerHTML = `
    <div class="info-message success">
      <span>âœ…</span>
      <div>
        <strong>Ready to record!</strong><br>
        Module: ${formData.module || 'Not set'}<br>
        Meeting Type: ${formData.meetingType || 'Not set'}<br>
        ${formData.files.length > 0 ? formData.files.length + ' file(s) uploaded<br>' : ''}
        ${formData.pdfText ? 'ğŸ“„ PDF loaded: ' + (formData.pdfText.length/1000).toFixed(1) + 'k characters' : ''}
      </div>
    </div>
    
    <div class="recording-interface">
      <button class="record-button" id="recordButton">
        <span id="recordButtonText">Open Recorder</span>
      </button>
      
      <div class="recording-status" id="recordingStatus">Ready to record</div>
      
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
      <button class="btn btn-secondary" id="stopRecordingBtn" style="display: none;">
        Stop Recording
      </button>
    </div>
  `;
  
  // é‡æ–°ç»‘å®šäº‹ä»¶
  const recordButton = document.getElementById('recordButton');
  if (recordButton) {
    recordButton.addEventListener('click', toggleRecording);
  }
  
  const stopBtn = document.getElementById('stopRecordingBtn');
  if (stopBtn) {
    stopBtn.addEventListener('click', stopExternalRecording);
  }
}

    // // Summary Display
    // function displaySummaryResults(results) {
    //   const page4 = document.getElementById('page4');
    //   page4.innerHTML = `
    //     <h2 style="margin-bottom: 24px;">Meeting Summary</h2>
    //     <div style="background: #f7f7f7; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
    //       <h3 style="margin-bottom: 8px;">Overview</h3>
    //       <p>${results.overview || 'Processing...'}</p>
    //     </div>
    //     <div style="margin-top: 24px; text-align: center;">
    //       <button class="btn btn-primary" onclick="insertToFigma()">Insert to Figma</button>
    //     </div>
    //   `;
    // }

    // Summary Display with animations
function displaySummaryResults(results) {
  // Update statistics (demo values)
  updateStatistics();
  
  // Start timer animation
  startTimerAnimation();
  
  // If we have real results, update the content
  if (results) {
    if (results.overview || results.summary) {
      document.getElementById('meetingOverview').innerHTML = results.overview || results.summary;
    }
    if (results.decisions && results.decisions.length > 0) {
      document.getElementById('keyDecisions').innerHTML = results.decisions.map(d => `â€¢ ${d}`).join('<br>');
      document.getElementById('decisionsCount').textContent = results.decisions.length;
    }
    if (results.actionItems && results.actionItems.length > 0) {
      document.getElementById('actionItems').innerHTML = results.actionItems.map(a => `â€¢ ${a}`).join('<br>');
      document.getElementById('actionsCount').textContent = results.actionItems.length;
    }
  }
}

// Add demo functions for statistics animation
function updateStatistics() {
  // Animate number counting
  animateNumber('cardsCount', 0, 7, 1000);
  animateNumber('decisionsCount', 0, 3, 1200);
  animateNumber('speakersCount', 0, 4, 1400);
  animateNumber('actionsCount', 0, 5, 1600);
}

function animateNumber(elementId, start, end, duration) {
  const element = document.getElementById(elementId);
  if (!element) return;
  
  const increment = (end - start) / (duration / 50);
  let current = start;
  
  const timer = setInterval(() => {
    current += increment;
    if (current >= end) {
      current = end;
      clearInterval(timer);
    }
    element.textContent = Math.floor(current);
  }, 50);
}

function startTimerAnimation() {
  let seconds = 148; // 2:28 in seconds
  
  const updateTimer = setInterval(() => {
    seconds--;
    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    const timerElement = document.getElementById('timerText');
    if (timerElement) {
      timerElement.textContent = `in ${minutes}:${secs.toString().padStart(2, '0')}`;
    }
    
    if (seconds <= 0) {
      clearInterval(updateTimer);
      if (timerElement) {
        timerElement.textContent = 'Processing...';
      }
    }
  }, 1000);
}

// Add export function
window.exportSummary = function() {
  showMessage('Export feature coming soon!', 'info');
}
// å…¨å±€å˜é‡
let recordingStartTime = null;
let durationUpdateInterval = null;
let nextSegmentCountdownInterval = null;
let latestDecisionsData = [];

// 1ï¸âƒ£ åˆå§‹åŒ–è¿›åº¦ç›‘æ§
window.initializeProgressMonitoring = function() {
  console.log('ğŸ¯ Starting progress monitoring');
  
  recordingStartTime = Date.now();
  const intervalMin = formData.intervalMin || 5;
  
  // æ˜¾ç¤ºå¼€å§‹æ—¶é—´
  const startTimeDisplay = document.getElementById('startTimeDisplay');
  if (startTimeDisplay) {
    startTimeDisplay.textContent = new Date().toLocaleTimeString([], { 
      hour: '2-digit', 
      minute: '2-digit' 
    });
  }
  
  // å¯åŠ¨å®šæ—¶å™¨
  startDurationTimer();
  startNextSegmentCountdown(intervalMin);
  updateProgressStats(0, 0);
}

// 2ï¸âƒ£ æ—¶é•¿å®šæ—¶å™¨ï¼ˆæ¯ç§’æ›´æ–°ï¼‰
function startDurationTimer() {
  if (durationUpdateInterval) clearInterval(durationUpdateInterval);
  
  durationUpdateInterval = setInterval(() => {
    if (!recordingStartTime) return;
    
    const elapsed = Date.now() - recordingStartTime;
    const minutes = Math.floor(elapsed / 60000);
    const seconds = Math.floor((elapsed % 60000) / 1000);
    
    const durationDisplay = document.getElementById('durationDisplay');
    if (durationDisplay) {
      durationDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }
  }, 1000);
}

// 3ï¸âƒ£ å€’è®¡æ—¶å®šæ—¶å™¨ï¼ˆæ¯ç§’æ›´æ–°ï¼‰
function startNextSegmentCountdown(intervalMin) {
  if (nextSegmentCountdownInterval) clearInterval(nextSegmentCountdownInterval);
  
  const intervalMs = intervalMin * 60000;
  let nextSegmentTime = Date.now() + intervalMs;
  
  nextSegmentCountdownInterval = setInterval(() => {
    const remaining = nextSegmentTime - Date.now();
    
    if (remaining <= 0) {
      nextSegmentTime = Date.now() + intervalMs;
      const reminderText = document.getElementById('segmentReminderText');
      if (reminderText) {
        reminderText.innerHTML = 'New segment analyzed! Click <strong>Refresh</strong> to update.';
        setTimeout(() => {
          reminderText.innerHTML = `Recording in progress. Next AI analysis in <strong id="segmentCountdown">--</strong>`;
        }, 3000);
      }
    }
    
    updateSegmentCountdown(Math.floor(remaining / 1000));
  }, 1000);
}

// 4ï¸âƒ£ æ›´æ–°å€’è®¡æ—¶æ˜¾ç¤º
function updateSegmentCountdown(totalSeconds) {
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  
  const nextSegmentTime = document.getElementById('nextSegmentTime');
  if (nextSegmentTime) {
    nextSegmentTime.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
  }
  
  const segmentCountdown = document.getElementById('segmentCountdown');
  if (segmentCountdown) {
    segmentCountdown.textContent = `${minutes}m ${seconds}s`;
  }
}

// 5ï¸âƒ£ æ›´æ–°ç»Ÿè®¡æ•°æ®
window.updateProgressStats = function(decisionsCount, speakersCount) {
  const decisionsCountEl = document.getElementById('decisionsCount');
  const speakersCountEl = document.getElementById('speakersCount');
  
  if (decisionsCountEl) decisionsCountEl.textContent = decisionsCount;
  if (speakersCountEl) speakersCountEl.textContent = speakersCount;
}

// 6ï¸âƒ£ æ›´æ–°æœ€æ–°å†³ç­–
window.updateLatestDecisions = function(decisions) {
  latestDecisionsData = decisions;
  
  const latestDecisionsEl = document.getElementById('latestDecisions');
  if (!latestDecisionsEl) return;
  
  if (!decisions || decisions.length === 0) {
    latestDecisionsEl.innerHTML = '<em style="color: #999;">No decisions recorded yet. AI will analyze the discussion periodically.</em>';
    return;
  }
  
  const latest = decisions.slice(-3);
  latestDecisionsEl.innerHTML = latest.map((d, index) => {
    const decisionText = typeof d === 'string' ? d : (d.decision || d.text || '');
    const decisionNumber = typeof d === 'object' ? d.decision_number : (decisions.length - 2 + index);
    return `<div style="margin-bottom: 8px;">
      <strong style="color: #5E5CE6;">Decision ${decisionNumber}:</strong> ${decisionText}
    </div>`;
  }).join('');
}

// 7ï¸âƒ£ åˆ·æ–°æŒ‰é’®
window.refreshProgress = function() {
  console.log('ğŸ”„ Refreshing');
  if (latestDecisionsData && latestDecisionsData.length > 0) {
    updateLatestDecisions(latestDecisionsData);
  }
  showMessage('âœ… Progress refreshed!', 'success');
}

// 8ï¸âƒ£ è¿”å›å½•éŸ³é¡µé¢
window.goBackToRecording = function() {
  changePage(-1);
}

// 9ï¸âƒ£ åœæ­¢ç›‘æ§
window.stopProgressMonitoring = function() {
  console.log('â¹ï¸ Stopping monitoring');
  
  if (durationUpdateInterval) {
    clearInterval(durationUpdateInterval);
    durationUpdateInterval = null;
  }
  
  if (nextSegmentCountdownInterval) {
    clearInterval(nextSegmentCountdownInterval);
    nextSegmentCountdownInterval = null;
  }
  
  recordingStartTime = null;
}
    // Figma Integration
   window.insertToFigma = function() {
  // æ”¶é›†é¡µé¢ä¸Šçš„æ•°æ®
  const summaryText = `
Meeting Overview:
${document.getElementById('meetingOverview')?.textContent || 'No overview'}

Key Decisions:
${document.getElementById('keyDecisions')?.textContent || 'No decisions'}

Action Items:
${document.getElementById('actionItems')?.textContent || 'No actions'}
  `;
  
  console.log("Inserting to Figma:", summaryText);
  
  parent.postMessage({
    pluginMessage: {
      type: 'insert-summary',
      data: {
        summaryText: summaryText,
        formData: formData
      }
    }
  }, '*');
  
  // é€šçŸ¥ç”¨æˆ·
  showMessage('Summary inserted to Figma!', 'success');
}

    // Utility Functions
    function showMessage(message, type = 'info') {
      const messageDiv = document.createElement('div');
      messageDiv.className = `info-message ${type}`;
      messageDiv.style.position = 'fixed';
      messageDiv.style.top = '20px';
      messageDiv.style.left = '50%';
      messageDiv.style.transform = 'translateX(-50%)';
      messageDiv.style.zIndex = '1000';
      messageDiv.innerHTML = `<span>${message}</span>`;
      
      document.body.appendChild(messageDiv);
      
      setTimeout(() => {
        messageDiv.remove();
      }, 3000);
    }

    // Make changePage globally accessible
    window.changePage = changePage;

    // ===== é…ç½®ç®¡ç† =====
// ç§»é™¤ç¡¬ç¼–ç çš„BASE_URLï¼Œæ”¹ä¸ºç¯å¢ƒå˜é‡æˆ–åŠ¨æ€é…ç½®
// ä¿®æ”¹ changePage å‡½æ•°
function changePage(direction) {
  // å¦‚æœåœ¨å½•éŸ³é¡µé¢ä¸”æ­£åœ¨å½•éŸ³ï¼Œå…ˆåœæ­¢
  if (currentPage === 3 && direction > 0 && isExternalRecording) {
    stopExternalRecording();
    return;
  }
  
  // ä¿å­˜å½“å‰é¡µé¢æ•°æ®
  savePageData();
  
  // éªŒè¯
  if (direction > 0 && !validateCurrentPage()) {
    showMessage('Please fill in all required fields', 'warning');
    return;
  }
  
  // åˆ‡æ¢é¡µé¢
  currentPage += direction;
  if (currentPage < 1) currentPage = 1;
  if (currentPage > totalPages) currentPage = totalPages;
  
  // å‡†å¤‡å½•éŸ³é¡µé¢
  if (currentPage === 3) {
    console.log('è¿›å…¥å½•éŸ³é¡µï¼Œå½“å‰formData:', formData);
    prepareRecordingPage();
  }
  
  updatePageDisplay();
  animatePageTransition();
}
const API_CONFIG = {
  // ä»ç¯å¢ƒè·å–æˆ–ä½¿ç”¨é»˜è®¤å€¼
  BASE_URL: window.API_BASE_URL || 'https://fyp-2025-kath.vercel.app',
  endpoints: {
    controlSignals: '/api/stop',
    sessions: '/api/get',
    savePdf: '/api/save_pdf',
    stopRecording: '/api/stop',
    ingestPdf: '/api/ingest_pdf'
  },
  // è½®è¯¢é…ç½®
  polling: {
    interval: 2000,
    maxRetries: 3,
    timeout: 30000
  }
};

// ===== å½•éŸ³ç›¸å…³å…¨å±€å˜é‡ï¼ˆä¿æŒä¸å˜ï¼‰=====
let recordingWindow = null;
let recordingSessionId = null;
let isExternalRecording = false;
let pollInterval = null;
let pollRetryCount = 0;

// ===== ç»Ÿä¸€çš„APIè°ƒç”¨å‡½æ•°ï¼ˆæ–°å¢ï¼‰=====
async function apiCall(endpoint, options = {}) {
  const url = endpoint.startsWith('http') 
    ? endpoint 
    : `${API_CONFIG.BASE_URL}${endpoint}`;
  
  const defaultOptions = {
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    },
    ...options
  };
  
  try {
    const response = await fetch(url, defaultOptions);
    
    if (!response.ok) {
      throw new Error(`API call failed: ${response.status} ${response.statusText}`);
    }
    
    return response;
  } catch (error) {
    console.error(`API call error for ${endpoint}:`, error);
    
    // å¢åŠ é‡è¯•é€»è¾‘
    if (options.retry !== false && pollRetryCount < API_CONFIG.polling.maxRetries) {
      pollRetryCount++;
      console.log(`Retrying API call (${pollRetryCount}/${API_CONFIG.polling.maxRetries})...`);
      await new Promise(resolve => setTimeout(resolve, 1000));
      return apiCall(endpoint, { ...options, retry: false });
    }
    
    throw error;
  }
}

// ===== ä¿®æ”¹ toggleRecording å‡½æ•°ï¼ˆä¿æŒä¸å˜ï¼‰=====
async function openExternalRecorder() {
  console.log('ğŸš€ å‡†å¤‡å½•éŸ³ä¼šè¯');

  if (!formData.module || !formData.meetingType) {
    console.warn('âš ï¸ è¡¨å•æ•°æ®ä¸å®Œæ•´ï¼Œå°è¯•é‡æ–°è·å–...');
    savePageData();  // å°è¯•ä¿å­˜å½“å‰æ•°æ®
    
    // å¦‚æœè¿˜æ˜¯æ²¡æœ‰ï¼Œæä¾›é»˜è®¤å€¼
    if (!formData.module) formData.module = 'DE4 ERO';
    if (!formData.meetingType) formData.meetingType = 'brainstorming';
  }
  
  console.log('ğŸ“‹ å½•éŸ³é…ç½®:', {
    module: formData.module,
    meetingType: formData.meetingType,
    role: formData.role
  });
  
  
  // ç”Ÿæˆsession ID
  recordingSessionId = Date.now().toString();
  
  // è·å–è®¾ç½®ï¼ˆä¿ç•™intervalMinåç§°ï¼‰
  const cycleInput = document.getElementById('cycleInput');
  const intervalMin = cycleInput ? parseInt(cycleInput.value || '10', 10) : 10;

  const params = new URLSearchParams({
    // åŸæœ‰å‚æ•°
    session: recordingSessionId,
    intervalMin: intervalMin.toString(),
    
    // æ–°å¢ï¼šè¡¨å•é…ç½®æ•°æ®
    module: formData.module || 'DE4 ERO',
    meetingType: formData.meetingType || 'brainstorming',
    role: formData.role || 'student',
    projectWeek: formData.projectWeek || '',
    groupName: formData.groupName || '',
    groupNumber: formData.groupNumber || '',
    meetingGoals: encodeURIComponent(formData.meetingGoals || ''),
    // å›¢é˜Ÿæˆå‘˜ç”¨ç«–çº¿åˆ†éš”ï¼Œé¿å…é€—å·é€ æˆçš„è§£æé—®é¢˜
    teamMembers: (formData.teamMembers || []).join('|')
  });

  // æ‰“å¼€å½•éŸ³çª—å£ï¼ŒURL ç°åœ¨åŒ…å«æ‰€æœ‰éœ€è¦çš„æ•°æ®
  const recorderUrl = `${API_CONFIG.BASE_URL}/record.html?${params.toString()}`;
  console.log('ğŸ“¡ æ‰“å¼€å½•éŸ³çª—å£ï¼ŒURL:', recorderUrl);
  window.open(recorderUrl, 'recorder', 'width=400,height=400');

  parent.postMessage({
  pluginMessage: {
    type: 'start-meeting',
    data: {
      sessionId: recordingSessionId,
      intervalMin: intervalMin,
      module: formData.module,
      meetingType: formData.meetingType,
      role: formData.role,
      projectWeek: formData.projectWeek,
      teamMembers: formData.teamMembers || []
    }
  }
}, '*');
  
  
  // å…ˆä¿å­˜æ‰€æœ‰é…ç½®åˆ°æœåŠ¡å™¨
  const setupSuccess = await setupRecordingSession(intervalMin);
  
  if (!setupSuccess) {
    showMessage('Failed to setup recording session', 'warning');
    return;
  }
  
  // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„ç•Œé¢ï¼Œè®©ç”¨æˆ·ä¸»åŠ¨æ‰“å¼€å½•éŸ³é¡µé¢
  showRecordingInstructions(intervalMin);
}

async function setupRecordingSession(intervalMin) {
  try {
    console.log('ğŸ“¡ ä¿å­˜ä¼šè¯è®¾ç½®...');
    
    // 1. ä¿å­˜é…ç½®
    await apiCall(API_CONFIG.endpoints.controlSignals, {
      method: 'POST',
      body: JSON.stringify({
        session_id: recordingSessionId,
        command: 'set_cycle',
        value: intervalMin
      })
    });
    console.log(`âœ… é—´éš”è®¾ç½®å·²ä¿å­˜: æ¯${intervalMin}åˆ†é’Ÿè‡ªåŠ¨æ€»ç»“`);
    
    // 2. å¦‚æœæœ‰PDFï¼Œä¿å­˜å®ƒ
    if (formData.pdfText && formData.pdfText.trim().length > 0) {
      console.log('ğŸ“„ ä¿å­˜PDFå†…å®¹...');
      const pdfSaved = await savePdfToServer(recordingSessionId, formData.pdfText);
      if (pdfSaved) {
        console.log('âœ… PDFå·²ä¿å­˜');
      } else {
        console.warn('âš ï¸ PDFä¿å­˜å¤±è´¥ï¼Œä½†ç»§ç»­');
      }
    }
    // é¢å¤–æ˜¾ç¤ºè®¡ç®—ä¿¡æ¯
    const segmentsNeeded = Math.ceil(intervalMin / 5);
    console.log(`ğŸ“Š é…ç½®è¯¦æƒ…: ${segmentsNeeded}ä¸ª5åˆ†é’Ÿå½•éŸ³æ®µåè§¦å‘æ€»ç»“`);
    
    
    return true;
  } catch (err) {
    console.error('Setup failed:', err);
    return false;
  }
}

function showRecordingInstructions(intervalMin) {
  // è®¡ç®—éœ€è¦å‡ ä¸ª5åˆ†é’Ÿçš„segments
  const segmentsNeeded = Math.ceil(intervalMin / 5);
  const actualInterval = segmentsNeeded * 5;
  
  // ä¼ é€’intervalMinå‚æ•°åˆ°record.html
  const recordingURL = `${API_CONFIG.BASE_URL}/record.html?session=${recordingSessionId}&intervalMin=${intervalMin}&start=true`;
  
  // æ›´æ–°å½•éŸ³é¡µé¢UI
  const recordingInterface = document.getElementById('recording-interface');
  if (recordingInterface) {
    recordingInterface.innerHTML = `
      <div style="text-align: center; padding: 20px;">
        <div class="info-message success" style="margin-bottom: 20px;">
          <span>âœ…</span>
          <span>Recording session ready! Choose how to open:</span>
        </div>
        
        <div style="background: #f7f7f7; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
          <p><strong>Session ID:</strong> ${recordingSessionId}</p>
          <p><strong>Processing:</strong> Every 5 minutes</p>
          <p><strong>Auto-summarize:</strong> Every ${actualInterval} minutes (${segmentsNeeded} segments)</p>
          ${intervalMin !== actualInterval ? `<p><small>Adjusted from ${intervalMin} to ${actualInterval} minutes</small></p>` : ''}
          ${formData.pdfText ? '<p>âœ… PDF document uploaded</p>' : ''}
        </div>
        
        <!-- Option 1: Copy Link -->
        <button class="btn btn-primary" onclick="copyRecordingLink('${recordingURL}')" style="margin: 10px;">
          ğŸ“‹ Copy Recording Link
        </button>
        
        <!-- Option 2: Try to Open -->
        <button class="btn btn-secondary" onclick="attemptOpenRecorder('${recordingURL}')" style="margin: 10px;">
          ğŸ”— Open Recording Page
        </button>
        
        <div style="margin-top: 30px;">
          <button class="btn btn-secondary" onclick="checkRecordingStatus()">
            Check Status
          </button>
          <button class="btn btn-secondary" onclick="stopExternalRecording()" style="margin-left: 10px;">
            Stop Recording
          </button>
        </div>
      </div>
    `;
  }
  
  // å¼€å§‹è½®è¯¢
  startPolling(recordingSessionId);
  
  // æ›´æ–°çŠ¶æ€
  isExternalRecording = true;
  isRecording = true;
  updateRecordingUI(true);
   formData.intervalMin = intervalMin;
  initializeProgressMonitoring();
}
async function stopExternalRecording() {
  console.log('ğŸ›‘ Stopping external recording...');
  
  // 1. å‘é€åœæ­¢ä¿¡å·åˆ°æœåŠ¡å™¨
  if (recordingSessionId) {
    try {
      await apiCall(API_CONFIG.endpoints.stopRecording, {
        method: 'POST',
        body: JSON.stringify({
          session_id: recordingSessionId,
          command: 'stop'
        })
      });
      console.log('âœ… Stop signal sent');
    } catch (err) {
      console.error('Error sending stop signal:', err);
    }
  }
  
  // 2. å…³é—­å½•éŸ³çª—å£
  if (recordingWindow && !recordingWindow.closed) {
    recordingWindow.close();
  }
  
  // 3. åœæ­¢è½®è¯¢
  if (pollInterval) {
    clearInterval(pollInterval);
    pollInterval = null;
  }
  
  // 4. æ›´æ–°çŠ¶æ€
  isExternalRecording = false;
  isRecording = false;
   stopProgressMonitoring();
  
  // 5. æ›´æ–°UI - æ˜¾ç¤ºå¤„ç†ä¸­
  updateRecordingUI(false, true);
  showMessage('Recording stopped. Processing results...', 'info');
  

  // 6. è·å–æœ€ç»ˆç»“æœå¹¶è·³è½¬åˆ°ç¬¬å››é¡µ
setTimeout(async () => {
  try {
    const res = await apiCall(`${API_CONFIG.endpoints.sessions}?session=${recordingSessionId}`);
    const data = await res.json();
    
    if (data && data.summary) {
      // ä¿å­˜ç»“æœ
      formData.results = {
        transcript: data.transcript || '',
        summary: data.summary || '',
        decisions: data.decision || [],
        explicit: data.explicit || [],
        tacit: data.tacit || [],
        reasoning: data.reasoning || '',
        suggestions: data.suggestions || []
      };
      
      displaySummaryResults(formData.results);
    } else {
      // å³ä½¿æ²¡æœ‰æ•°æ®ä¹Ÿæ˜¾ç¤ºdemoé¡µé¢
      displaySummaryResults(null);
    }
    
    // æ— è®ºå¦‚ä½•éƒ½è·³è½¬åˆ°ç¬¬å››é¡µ
    currentPage = 4;
    updatePageDisplay();
    
  } catch (err) {
    console.error('Error fetching final results:', err);
    // å‡ºé”™æ—¶ä¹Ÿæ˜¾ç¤ºdemoé¡µé¢
    currentPage = 4;
    updatePageDisplay();
    displaySummaryResults(null);
  }
  
  // é‡ç½®UI
  resetRecordingUI();
}, 2000);
  // // 6. è·å–æœ€ç»ˆç»“æœ
  // setTimeout(async () => {
  //   try {
  //     const res = await apiCall(`${API_CONFIG.endpoints.sessions}?session=${recordingSessionId}`);
  //     const data = await res.json();
      
  //     if (data && data.summary) {
  //       // ä¿å­˜ç»“æœ
  //       formData.results = {
  //         transcript: data.transcript || '',
  //         summary: data.summary || '',
  //         decisions: data.decision || [],
  //         explicit: data.explicit || [],
  //         tacit: data.tacit || [],
  //         reasoning: data.reasoning || '',
  //         suggestions: data.suggestions || []
  //       };
        
  //       // æ˜¾ç¤ºç»“æœé¡µ
  //       currentPage = 4;
  //       updatePageDisplay();
  //       displaySummaryResults(formData.results);
  //     }
  //   } catch (err) {
  //     console.error('Error fetching final results:', err);
  //   }
    
  //   // é‡ç½®UI
  //   resetRecordingUI();
  // }, 2000);
}


// ===== æ–°å¢ï¼šæ˜¾ç¤ºå¼¹çª—è¢«æ‹¦æˆªçš„æ¶ˆæ¯å’Œæ›¿ä»£æ–¹æ¡ˆ =====
function showPopupBlockedMessage() {
  const messageHTML = `
    <div id="popupBlockedMessage" style="
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border: 2px solid #ff9800;
      border-radius: 8px;
      padding: 20px;
      z-index: 10000;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      max-width: 400px;
    ">
      <h3 style="margin-top: 0; color: #ff9800;">âš ï¸ Popup Blocked</h3>
      <p>Your browser blocked the recording window. Please choose an option:</p>
      
      <div style="margin: 15px 0;">
        <button onclick="allowPopupAndRetry()" style="
          background: #4CAF50;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
          cursor: pointer;
          margin-right: 10px;
        ">
          Allow Popups & Retry
        </button>
        
        <button onclick="openInNewTab()" style="
          background: #2196F3;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
          cursor: pointer;
        ">
          Open in New Tab
        </button>
      </div>
      
      <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
        <p style="margin: 0; font-size: 14px; color: #666;">
          <strong>To enable popups:</strong><br>
          1. Click the popup blocker icon in your browser's address bar<br>
          2. Select "Always allow popups from this site"<br>
          3. Click the recording button again
        </p>
      </div>
      
      <button onclick="closePopupMessage()" style="
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: #999;
      ">Ã—</button>
    </div>
  `;
  
  // æ·»åŠ åˆ°é¡µé¢
  const div = document.createElement('div');
  div.innerHTML = messageHTML;
  document.body.appendChild(div);
}

// ===== è¾…åŠ©å‡½æ•°ï¼šé‡è¯•æ‰“å¼€å¼¹çª— =====
window.allowPopupAndRetry = function() {
  closePopupMessage();
  
  // æç¤ºç”¨æˆ·å…ˆå…è®¸å¼¹çª—
  alert('Please allow popups for this site in your browser settings, then click OK to retry.');
  
  // é‡è¯•æ‰“å¼€
  setTimeout(() => {
    openExternalRecorder();
  }, 100);
};

// ===== è¾…åŠ©å‡½æ•°ï¼šåœ¨æ–°æ ‡ç­¾é¡µæ‰“å¼€ =====
window.openInNewTab = function() {
  closePopupMessage();
  
  // ç”Ÿæˆsession ID
  recordingSessionId = Date.now().toString();
  
  // åœ¨æ–°æ ‡ç­¾é¡µæ‰“å¼€
  const recordUrl = `${API_CONFIG.BASE_URL}/record.html?session=${recordingSessionId}&start=true`;
  const newTab = window.open(recordUrl, '_blank');
  
  if (newTab) {
    // æ›´æ–°UIçŠ¶æ€
    updateRecordingUI(true);
    isExternalRecording = true;
    isRecording = true;
    
    // å¼€å§‹è½®è¯¢
    startPolling(recordingSessionId);
    
    // è®¾ç½®è®°å½•çª—å£å¼•ç”¨
    recordingWindow = newTab;
    checkRecordingWindowStatus();
    
    // ä¿å­˜è®¾ç½®
    saveRecordingSettings(recordingSessionId);
  }
};

// ===== è¾…åŠ©å‡½æ•°ï¼šå…³é—­å¼¹çª—æ¶ˆæ¯ =====
window.closePopupMessage = function() {
  const message = document.getElementById('popupBlockedMessage');
  if (message) {
    message.parentElement.remove();
  }
};

// ===== è¾…åŠ©å‡½æ•°ï¼šä¿å­˜å½•éŸ³è®¾ç½® =====
async function saveRecordingSettings(sessionId) {
  const cycleInput = document.getElementById('cycleInput');
  const intervalMin = cycleInput ? parseInt(cycleInput.value || '5', 10) : 5;
  
  try {
    await apiCall(API_CONFIG.endpoints.controlSignals, {
      method: 'POST',
      body: JSON.stringify({
        session_id: sessionId,
        command: 'set_cycle',
        value: intervalMin
      })
    });
    
    if (formData.pdfText) {
      await savePdfToServer(sessionId, formData.pdfText);
    }
  } catch (err) {
    console.error('Error saving settings:', err);
  }
}

// ===== æ–°å¢ï¼šç›‘æ§å½•éŸ³çª—å£çŠ¶æ€ =====
function checkRecordingWindowStatus() {
  const checkInterval = setInterval(() => {
    if (recordingWindow && recordingWindow.closed) {
      // çª—å£è¢«ç”¨æˆ·å…³é—­
      console.log('Recording window was closed by user');
      clearInterval(checkInterval);
      
      if (isExternalRecording) {
        // å¦‚æœè¿˜åœ¨å½•éŸ³ä¸­ï¼Œåœæ­¢å½•éŸ³
        stopExternalRecording();
      }
    }
    
    if (!isExternalRecording) {
      // å½•éŸ³å·²åœæ­¢ï¼Œåœæ­¢æ£€æŸ¥
      clearInterval(checkInterval);
    }
  }, 1000);
}

// ===== æ›¿ä»£æ–¹æ¡ˆï¼šä½¿ç”¨å†…åµŒiframeï¼ˆå¦‚æœå…è®¸ï¼‰=====
function openRecorderInIframe() {
  const iframeHTML = `
    <div id="recorderIframeContainer" style="
      position: fixed;
      top: 10%;
      left: 10%;
      width: 80%;
      height: 80%;
      background: white;
      border: 2px solid #333;
      border-radius: 8px;
      z-index: 9999;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    ">
      <div style="
        background: #333;
        color: white;
        padding: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      ">
        <span>Recording Window</span>
        <button onclick="closeRecorderIframe()" style="
          background: #ff4444;
          color: white;
          border: none;
          padding: 5px 15px;
          border-radius: 4px;
          cursor: pointer;
        ">Close</button>
      </div>
      <iframe 
        id="recorderIframe"
        src="${API_CONFIG.BASE_URL}/record.html?session=${recordingSessionId}&start=true"
        style="width: 100%; height: calc(100% - 40px); border: none;">
      </iframe>
    </div>
  `;
  
  const div = document.createElement('div');
  div.innerHTML = iframeHTML;
  document.body.appendChild(div);
}

window.closeRecorderIframe = function() {
  const container = document.getElementById('recorderIframeContainer');
  if (container) {
    container.remove();
    if (isExternalRecording) {
      stopExternalRecording();
    }
  }
};
// function startPolling(sessionId) {
//   let lastShownSummary = '';
//   let pollTimeoutId = null;
  
//   // è®¾ç½®è¶…æ—¶
//   pollTimeoutId = setTimeout(() => {
//     if (pollInterval) {
//       clearInterval(pollInterval);
//       console.warn('Polling timeout reached');
//       showError('Recording timeout. Please check your connection and try again.');
//     }
//   }, API_CONFIG.polling.timeout);
  
//   pollInterval = setInterval(async () => {
//     try {
//       const res = await apiCall(`${API_CONFIG.endpoints.sessions}?session=${sessionId}`);
//       const data = await res.json();
      
//       if (data && data.summary && data.summary !== lastShownSummary) {
//         lastShownSummary = data.summary;
        
//         // æ¸…é™¤è¶…æ—¶
//         if (pollTimeoutId) {
//           clearTimeout(pollTimeoutId);
//         }
        
//         // å­˜å‚¨ç»“æœï¼ˆå¢åŠ æ•°æ®éªŒè¯ï¼‰
//         formData.results = {
//           transcript: data.transcript || '',
//           summary: data.summary || '',
//           decisions: Array.isArray(data.decision) ? data.decision : [],
//           explicit: Array.isArray(data.explicit) ? data.explicit : [],
//           tacit: Array.isArray(data.tacit) ? data.tacit : [],
//           reasoning: data.reasoning || '',
//           suggestions: Array.isArray(data.suggestions) ? data.suggestions : []
//         };
        
//         // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
//         await saveToPluginStorage('lastMeetingResults', formData.results);
        
//         // å¦‚æœå½•éŸ³å·²åœæ­¢ï¼Œæ˜¾ç¤ºç»“æœ
//         if (!isExternalRecording) {
//           clearInterval(pollInterval);
//           displaySummaryResults(formData.results);
          
//           // å‘é€ç»™Figmaæ’ä»¶
//           sendResultsToFigma(data);
//         }
//       }
//     } catch (err) {
//       console.error('Polling error:', err);
//       // ä¸ç«‹å³åœæ­¢è½®è¯¢ï¼Œå¯èƒ½æ˜¯ä¸´æ—¶ç½‘ç»œé—®é¢˜
//     }
//   }, API_CONFIG.polling.interval);
// }
function startPolling(sessionId) {
  // åˆå§‹åŒ–çŠ¶æ€å˜é‡
  let lastTranscript = '';          // ä¸Šæ¬¡å¤„ç†çš„transcript
  let lastDecisions = [];           // ç´¯ç§¯çš„å†³ç­–åˆ—è¡¨
  let pollTimeoutId = null;         // è¶…æ—¶è®¡æ—¶å™¨ID
  let pollCount = 0;                // è½®è¯¢æ¬¡æ•°è®¡æ•°
  
  console.log('ğŸ”„ å¼€å§‹è½®è¯¢ï¼ŒSession ID:', sessionId);
  
  // è®¾ç½®è¶…æ—¶å¤„ç†ï¼ˆ30ç§’ååœæ­¢è½®è¯¢ï¼‰
  pollTimeoutId = setTimeout(() => {
    if (pollInterval) {
      clearInterval(pollInterval);
      console.warn('âš ï¸ è½®è¯¢è¶…æ—¶');
      showMessage('Recording timeout. Please check your connection.', 'warning');
    }
  }, API_CONFIG.polling.timeout || 30000);
  
  // å¼€å§‹å®šæœŸè½®è¯¢
  pollInterval = setInterval(async () => {
    pollCount++;
    console.log(`ğŸ“¡ è½®è¯¢ #${pollCount} - Session: ${sessionId}`);
    
    try {
      // 1. ä»æœåŠ¡å™¨è·å–å½“å‰transcript
      const res = await fetch(`${API_CONFIG.BASE_URL}/api/get?session=${sessionId}`);
      
      if (!res.ok) {
        console.error('âŒ è½®è¯¢è¯·æ±‚å¤±è´¥:', res.status);
        return;
      }
      
      const data = await res.json();
      
      // 2. æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„transcriptå†…å®¹
      if (data && data.transcript) {
        // æ£€æŸ¥transcriptæ˜¯å¦æœ‰æ›´æ–°
        const currentTranscript = data.transcript;
        const hasNewContent = currentTranscript.length > lastTranscript.length;
        
        if (hasNewContent) {
          console.log('ğŸ“ å‘ç°æ–°å†…å®¹ï¼Œé•¿åº¦:', currentTranscript.length);
          
          // æ¸…é™¤è¶…æ—¶ï¼ˆè¯´æ˜è¿˜åœ¨æ´»åŠ¨ï¼‰
          if (pollTimeoutId) {
            clearTimeout(pollTimeoutId);
            // é‡æ–°è®¾ç½®è¶…æ—¶
            pollTimeoutId = setTimeout(() => {
              clearInterval(pollInterval);
              console.warn('âš ï¸ è½®è¯¢è¶…æ—¶');
            }, 30000);
          }
          
          // 3. æå–æ–°å¢çš„éƒ¨åˆ†
          const newSegment = currentTranscript.substring(lastTranscript.length);
          console.log('ğŸ†• æ–°å¢å†…å®¹é•¿åº¦:', newSegment.length);
          
          // 4. è°ƒç”¨å®æ—¶åˆ†æï¼ˆå¦‚æœæ–°å†…å®¹è¶³å¤Ÿé•¿ï¼‰
          if (newSegment.length > 50) {  // è‡³å°‘50ä¸ªå­—ç¬¦æ‰åˆ†æ
            console.log('ğŸ¯ è°ƒç”¨å®æ—¶åˆ†æ...');
            
            // å‡†å¤‡é¿å…é‡å¤çš„å†…å®¹
            const avoidContent = lastDecisions.length > 0 
              ? JSON.stringify(lastDecisions) 
              : '';
            
            // è°ƒç”¨å®æ—¶åˆ†æAPI
            const analysisResult = await callRealtimeSummarize(
              newSegment,  // åªåˆ†ææ–°å¢éƒ¨åˆ†
              avoidContent // ä¼ é€’ä¹‹å‰çš„å†³ç­–ä»¥é¿å…é‡å¤
            );
            
            // 5. å¤„ç†åˆ†æç»“æœ
            if (analysisResult && analysisResult.decisions) {
              const newDecisions = analysisResult.decisions;
              
              if (newDecisions.length > 0) {
                console.log(`âœ… å‘ç° ${newDecisions.length} ä¸ªæ–°å†³ç­–`);
                
                // é‡æ–°ç¼–å·å†³ç­–
                newDecisions.forEach((decision, index) => {
                  decision.decision_number = lastDecisions.length + index + 1;
                });
                
                // ç´¯ç§¯å†³ç­–
                lastDecisions = [...lastDecisions, ...newDecisions];
                
                // æ›´æ–°UI
                displayRealtimeDecisions(lastDecisions);
                
                // ä¿å­˜åˆ°formData
                formData.results = {
                  ...formData.results,
                  decisions: lastDecisions,
                  transcript: currentTranscript,
                  analysisTime: new Date().toISOString()
                };
                
                // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
                saveToPluginStorage('lastMeetingResults', formData.results);
                
                // æ˜¾ç¤ºé€šçŸ¥
                showMessage(`Found ${newDecisions.length} new decision(s)`, 'success');
              }
            }
          }
          
          // æ›´æ–°lastTranscript
          lastTranscript = currentTranscript;
        }
      }
      
      // 6. æ£€æŸ¥æ˜¯å¦åº”è¯¥æ‰§è¡Œæ€»ç»“ï¼ˆåŸºäºé—´éš”è®¾ç½®ï¼‰
      const cycleInput = document.getElementById('cycleInput');
      const intervalMin = parseInt(cycleInput?.value || '5');
      const shouldSummarize = pollCount % (intervalMin * 12) === 0;  // æ¯åˆ†é’Ÿè½®è¯¢12æ¬¡ï¼ˆ5ç§’ä¸€æ¬¡ï¼‰
      
      if (shouldSummarize && data.transcript) {
        console.log('ğŸ“Š è§¦å‘å‘¨æœŸæ€§æ€»ç»“...');
        
        // è¿™é‡Œå¯ä»¥è°ƒç”¨æ›´å…¨é¢çš„åˆ†æ
        // ä½†é€šå¸¸å®æ—¶åˆ†æå°±è¶³å¤Ÿäº†
      }
      
      // 7. å¦‚æœå½•éŸ³å·²åœæ­¢
      if (data.recording_stopped || !isExternalRecording) {
        console.log('ğŸ›‘ æ£€æµ‹åˆ°å½•éŸ³åœæ­¢');
        clearInterval(pollInterval);
        clearTimeout(pollTimeoutId);
        
        // æœ€ç»ˆå¤„ç†
        if (lastDecisions.length > 0) {
          displaySummaryResults(formData.results);
        }
        
        // å‘é€ç»“æœç»™Figmaæ’ä»¶
        if (data) {
          sendResultsToFigma({
            ...data,
            decisions: lastDecisions
          });
        }
      }
      
    } catch (err) {
      console.error('âŒ è½®è¯¢é”™è¯¯:', err);
      
      // é”™è¯¯é‡è¯•æœºåˆ¶
      pollRetryCount = (pollRetryCount || 0) + 1;
      
      if (pollRetryCount >= API_CONFIG.polling.maxRetries) {
        console.error('âŒ è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œåœæ­¢è½®è¯¢');
        clearInterval(pollInterval);
        clearTimeout(pollTimeoutId);
        showMessage('Connection lost. Please check your network.', 'error');
      }
    }
    
  }, API_CONFIG.polling.interval || 5000);  // æ¯5ç§’è½®è¯¢ä¸€æ¬¡
  
  // è¿”å›æ¸…ç†å‡½æ•°
  return () => {
    if (pollInterval) {
      clearInterval(pollInterval);
      pollInterval = null;
    }
    if (pollTimeoutId) {
      clearTimeout(pollTimeoutId);
      pollTimeoutId = null;
    }
  };
}

// ===== è¾…åŠ©å‡½æ•°ï¼šåœæ­¢è½®è¯¢ =====
function stopPolling() {
  if (pollInterval) {
    clearInterval(pollInterval);
    pollInterval = null;
    console.log('ğŸ›‘ è½®è¯¢å·²åœæ­¢');
  }
}
// ===== ä¼˜åŒ–çš„PDFä¿å­˜å‡½æ•° =====

async function savePdfToServer(sessionId, pdfText) {
  console.log('ğŸ“š === å¼€å§‹ savePdfToServer å‡½æ•° ===');
  
  // è¾“å…¥éªŒè¯
  if (!sessionId) {
    console.error('âŒ æ²¡æœ‰session ID');
    return false;
  }
  
  if (!pdfText || pdfText.trim().length === 0) {
    console.error('âŒ PDFæ–‡æœ¬ä¸ºç©º');
    return false;
  }
  
  // é™åˆ¶å¤§å°
  const maxLength = 500000;
  let textToSave = pdfText;
  if (pdfText.length > maxLength) {
    console.warn(`âš ï¸ PDFå¤ªå¤§ (${pdfText.length}å­—ç¬¦), æˆªæ–­åˆ°${maxLength}å­—ç¬¦`);
    textToSave = pdfText.substring(0, maxLength);
  }
  
  // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
  console.log('ğŸ“‹ PDFä¿å­˜å‚æ•°:');
  console.log('  - APIç«¯ç‚¹:', `${API_CONFIG.BASE_URL}${API_CONFIG.endpoints.savePdf}`);
  console.log('  - Session ID:', sessionId);
  console.log('  - åŸå§‹æ–‡æœ¬é•¿åº¦:', pdfText.length);
  console.log('  - ä¿å­˜æ–‡æœ¬é•¿åº¦:', textToSave.length);
  console.log('  - æ–‡ä»¶å:', formData.pdfFileName || 'context.pdf');
  console.log('  - æ¨¡å—:', formData.module || 'unknown');
  console.log('  - ä¼šè®®ç±»å‹:', formData.meetingType || 'unknown');
  
  try {
    // æ„å»ºè¯·æ±‚ä½“
    const requestBody = {
      session_id: sessionId,
      pdf_text: textToSave,
      filename: formData.pdfFileName || 'context.pdf',
      metadata: {
        uploadTime: new Date().toISOString(),
        textLength: textToSave.length,
        module: formData.module || 'unknown',
        meetingType: formData.meetingType || 'unknown'
      }
    };
    
    console.log('ğŸ“¤ å‘é€POSTè¯·æ±‚åˆ°:', `${API_CONFIG.BASE_URL}${API_CONFIG.endpoints.savePdf}`);
    console.log('ğŸ“¤ è¯·æ±‚ä½“å¤§å°:', JSON.stringify(requestBody).length, 'å­—ç¬¦');
    
    // å‘é€è¯·æ±‚
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.endpoints.savePdf}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestBody)
    });
    
    console.log('ğŸ“¥ å“åº”çŠ¶æ€ç :', response.status);
    console.log('ğŸ“¥ å“åº”çŠ¶æ€æ–‡æœ¬:', response.statusText);
    console.log('ğŸ“¥ å“åº”å¤´:', {
      'content-type': response.headers.get('content-type'),
      'content-length': response.headers.get('content-length')
    });
    
    // è·å–å“åº”æ–‡æœ¬
    const responseText = await response.text();
    console.log('ğŸ“¥ åŸå§‹å“åº”å†…å®¹:', responseText);
    console.log('ğŸ“¥ å“åº”é•¿åº¦:', responseText.length, 'å­—ç¬¦');
    
    // æ£€æŸ¥HTTPçŠ¶æ€
    if (!response.ok) {
      console.error('âŒ æœåŠ¡å™¨è¿”å›é”™è¯¯çŠ¶æ€:', response.status);
      console.error('âŒ é”™è¯¯è¯¦æƒ…:', responseText);
      
      // å°è¯•è§£æé”™è¯¯ä¿¡æ¯
      try {
        const errorData = JSON.parse(responseText);
        console.error('âŒ é”™è¯¯å¯¹è±¡:', errorData);
      } catch (e) {
        console.error('âŒ é”™è¯¯å“åº”ä¸æ˜¯JSONæ ¼å¼');
      }
      
      return false;
    }
    
    // å°è¯•è§£æJSONå“åº”
    let result = null;
    try {
      result = JSON.parse(responseText);
      console.log('âœ… æˆåŠŸè§£æJSONå“åº”:', result);
      
      // æ£€æŸ¥å“åº”ä¸­çš„æˆåŠŸæ ‡å¿—
      if (result.ok || result.success || result.status === 'success') {
        console.log('âœ… PDFæˆåŠŸä¿å­˜åˆ°Supabase!');
        console.log('  - ä¿å­˜æ—¶é—´:', new Date().toISOString());
        console.log('  - Session:', sessionId);
        return true;
      } else {
        console.warn('âš ï¸ å“åº”ä¸­æ²¡æœ‰æ˜ç¡®çš„æˆåŠŸæ ‡å¿—');
        console.log('  - å“åº”å¯¹è±¡:', result);
      }
      
    } catch (parseError) {
      console.warn('âš ï¸ å“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSON:', parseError.message);
      
      // å¦‚æœçŠ¶æ€ç æ˜¯200-299ï¼Œå³ä½¿ä¸æ˜¯JSONä¹Ÿè®¤ä¸ºæˆåŠŸ
      if (response.status >= 200 && response.status < 300) {
        console.log('âœ… åŸºäºHTTPçŠ¶æ€ç åˆ¤æ–­PDFå·²ä¿å­˜');
        console.log('  - çŠ¶æ€ç :', response.status);
        console.log('  - å“åº”å†…å®¹:', responseText.substring(0, 100));
        return true;
      }
    }
    
    // é»˜è®¤è¿”å›false
    console.warn('âš ï¸ æ— æ³•ç¡®è®¤PDFæ˜¯å¦ä¿å­˜æˆåŠŸ');
    return false;
    
  } catch (error) {
    console.error('âŒ PDFä¿å­˜è¿‡ç¨‹å‘ç”Ÿå¼‚å¸¸:', error);
    console.error('  - é”™è¯¯ç±»å‹:', error.name);
    console.error('  - é”™è¯¯æ¶ˆæ¯:', error.message);
    console.error('  - é”™è¯¯å †æ ˆ:', error.stack);
    
    // ç½‘ç»œé”™è¯¯ç‰¹æ®Šå¤„ç†
    if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
      console.error('âŒ ç½‘ç»œè¿æ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥:');
      console.error('  1. APIæœåŠ¡å™¨æ˜¯å¦è¿è¡Œ');
      console.error('  2. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸');
      console.error('  3. CORSè®¾ç½®æ˜¯å¦æ­£ç¡®');
    }
    
    return false;
    
  } finally {
    console.log('ğŸ“š === ç»“æŸ savePdfToServer å‡½æ•° ===');
  }
}

// ===== æ–°å¢è¾…åŠ©å‡½æ•° =====
function updateRecordingUI(isRecording, isProcessing = false) {
  const recordButton = document.getElementById('recordButton');
  const recordButtonText = document.getElementById('recordButtonText');
  const recordingStatus = document.getElementById('recordingStatus');
  const stopRecordingBtn = document.getElementById('stopRecordingBtn');
  const nextBtn = document.getElementById('nextBtn');
  
  if (isRecording) {
    recordButton?.classList.add('recording');
    if (recordButtonText) recordButtonText.textContent = 'Recording in Progress';
    if (recordingStatus) recordingStatus.textContent = 'Recording in external window - DO NOT CLOSE';
    if (stopRecordingBtn) stopRecordingBtn.style.display = 'block';
    if (nextBtn) nextBtn.style.display = 'none';
  } else if (isProcessing) {
    recordButton?.classList.remove('recording');
    if (recordButtonText) recordButtonText.textContent = 'Processing...';
    if (recordingStatus) recordingStatus.textContent = 'Processing your recording...';
    if (recordButton) recordButton.disabled = true;
    if (stopRecordingBtn) stopRecordingBtn.style.display = 'none';
  } else {
    resetRecordingUI();
  }
}

function resetRecordingUI() {
  const recordButton = document.getElementById('recordButton');
  const recordButtonText = document.getElementById('recordButtonText');
  const recordingStatus = document.getElementById('recordingStatus');
  const stopRecordingBtn = document.getElementById('stopRecordingBtn');
  const nextBtn = document.getElementById('nextBtn');
  
  recordButton?.classList.remove('recording');
  if (recordButtonText) recordButtonText.textContent = 'Start Recording';
  if (recordingStatus) recordingStatus.textContent = '';
  if (recordButton) recordButton.disabled = false;
  if (stopRecordingBtn) stopRecordingBtn.style.display = 'none';
  if (nextBtn) nextBtn.style.display = 'block';
}

function sendResultsToFigma(data) {
  parent.postMessage({
    pluginMessage: {
      type: 'analyze-transcript',
      transcript: data.transcript,
      summary: data.summary,
      decision: data.decision,
      explicit: data.explicit,
      tacit: data.tacit,
      reasoning: data.reasoning,
      suggestions: data.suggestions
    }
  }, '*');
}

function showError(message) {
  // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯çš„å‡½æ•°
  console.error(message);
  const errorDiv = document.getElementById('errorMessage');
  if (errorDiv) {
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
    setTimeout(() => {
      errorDiv.style.display = 'none';
    }, 5000);
  }
}

// ===== ä¿®æ”¹åŸæœ‰å‡½æ•°çš„å…¼å®¹æ€§åŒ…è£… =====
async function startRecording() {
  await openExternalRecorder();
}

function stopRecording() {
  if (isExternalRecording) {
    stopExternalRecording();
  }
}

// ===== åˆå§‹åŒ–æ—¶æ£€æŸ¥ç¯å¢ƒ =====
(function initializeAPIConfig() {
  // æ£€æŸ¥æ˜¯å¦åœ¨å¼€å‘ç¯å¢ƒ
  if (window.location.hostname === 'localhost') {
    API_CONFIG.BASE_URL = 'http://localhost:3000';
    console.log('Using local development server');
  }
  
  // æ£€æŸ¥æ˜¯å¦æœ‰è‡ªå®šä¹‰é…ç½®
  if (window.customAPIConfig) {
    Object.assign(API_CONFIG, window.customAPIConfig);
  }
})();

// å¤åˆ¶é“¾æ¥å‡½æ•°
window.copyRecordingLink = async function(url) {
  try {
    await navigator.clipboard.writeText(url);
    showMessage('Link copied! Paste it in your browser.', 'success');
  } catch (err) {
    // å¤‡ç”¨æ–¹æ³•
    const textArea = document.createElement('textarea');
    textArea.value = url;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    showMessage('Link copied!', 'success');
  }
}

// å°è¯•æ‰“å¼€å½•éŸ³é¡µé¢
window.attemptOpenRecorder = function(url) {
  console.log('ç”¨æˆ·ç‚¹å‡»æ‰“å¼€å½•éŸ³é¡µé¢');
  
  const newWindow = window.open(url, '_blank');
  
  if (!newWindow || newWindow.closed) {
    showMessage('Popup blocked. Please use "Copy Link" instead.', 'warning');
    // è‡ªåŠ¨å¤åˆ¶é“¾æ¥
    copyRecordingLink(url);
  } else {
    showMessage('Recording page opened!', 'success');
    recordingWindow = newWindow;
    checkRecordingWindowStatus();
  }
}

// æ£€æŸ¥å½•éŸ³çŠ¶æ€
window.checkRecordingStatus = async function() {
  try {
    const res = await fetch(`${API_CONFIG.BASE_URL}/api/get?session=${recordingSessionId}`);
    const data = await res.json();
    
    if (data && data.transcript) {
      showMessage('Recording in progress...', 'info');
    } else {
      showMessage('No recording detected yet', 'warning');
    }
  } catch (err) {
    showMessage('Could not check status', 'warning');
  }
}

  </script>
</body>
</html>

