<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Meeting Assistant</title>
  <style>
    /* [ä¿æŒåŸæœ‰çš„æ‰€æœ‰CSSæ ·å¼ä¸å˜] */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #ffffff;
      color: #333;
      padding: 0;
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Progress Indicator */
    .progress-bar {
      display: flex;
      justify-content: space-between;
      padding: 20px 24px;
      background: #f7f7f7;
      border-bottom: 1px solid #e5e5e5;
    }

    .progress-step {
      flex: 1;
      text-align: center;
      position: relative;
    }

    .progress-step::after {
      content: '';
      position: absolute;
      top: 15px;
      right: -50%;
      width: 100%;
      height: 2px;
      background: #e5e5e5;
      z-index: 0;
    }

    .progress-step:last-child::after {
      display: none;
    }

    .step-circle {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #e5e5e5;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: #999;
      position: relative;
      z-index: 1;
      transition: all 0.3s ease;
    }

    .progress-step.active .step-circle {
      background: #5E5CE6;
      color: white;
    }

    .progress-step.completed .step-circle {
      background: #30D158;
      color: white;
    }

    .step-label {
      margin-top: 8px;
      font-size: 11px;
      color: #666;
      font-weight: 500;
    }

    .progress-step.active .step-label {
      color: #5E5CE6;
      font-weight: 600;
    }

    /* Page Container */
    .page-container {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
    }

    .page {
      display: none;
      animation: fadeIn 0.3s ease;
    }

    .page.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Form Elements */
    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }

    input[type="text"],
    input[type="email"],
    select,
    textarea {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #d1d1d1;
      border-radius: 6px;
      font-size: 13px;
      transition: all 0.2s;
      background: white;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: #5E5CE6;
      box-shadow: 0 0 0 3px rgba(94, 92, 230, 0.1);
    }

    textarea {
      resize: vertical;
      min-height: 80px;
      font-family: inherit;
    }

    /* Radio/Checkbox Groups */
    .radio-group,
    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .radio-item,
    .checkbox-item {
      display: flex;
      align-items: center;
      padding: 12px;
      border: 1px solid #e5e5e5;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .radio-item:hover,
    .checkbox-item:hover {
      background: #f7f7f7;
      border-color: #5E5CE6;
    }

    .radio-item input[type="radio"],
    .checkbox-item input[type="checkbox"] {
      margin-right: 10px;
      cursor: pointer;
    }

    .radio-item.selected,
    .checkbox-item.selected {
      background: #F0F0FF;
      border-color: #5E5CE6;
    }

    /* File Upload Area */
    .upload-area {
      border: 2px dashed #d1d1d1;
      border-radius: 8px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      background: #fafafa;
    }

    .upload-area:hover {
      border-color: #5E5CE6;
      background: #F0F0FF;
    }

    .upload-area.dragover {
      border-color: #5E5CE6;
      background: #F0F0FF;
      transform: scale(1.02);
    }

    .upload-icon {
      font-size: 48px;
      color: #999;
      margin-bottom: 10px;
    }

    .upload-text {
      color: #666;
      font-size: 14px;
      margin-bottom: 8px;
    }

    .upload-hint {
      color: #999;
      font-size: 12px;
    }

    .file-list {
      margin-top: 16px;
    }

    .file-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: #f7f7f7;
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .file-name {
      font-size: 13px;
      color: #333;
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .file-remove {
      color: #999;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .file-remove:hover {
      background: #e5e5e5;
      color: #ff3b30;
    }

    /* Recording Interface */
    .recording-interface {
      text-align: center;
      padding: 40px 20px;
    }

    .record-button {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: linear-gradient(135deg, #FF3B30 0%, #FF6B6B 100%);
      border: none;
      color: white;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 20px rgba(255, 59, 48, 0.3);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .record-button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 30px rgba(255, 59, 48, 0.4);
    }

    .record-button.recording {
      background: linear-gradient(135deg, #666 0%, #999 100%);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 4px 20px rgba(255, 59, 48, 0.3); }
      50% { box-shadow: 0 4px 40px rgba(255, 59, 48, 0.6); }
      100% { box-shadow: 0 4px 20px rgba(255, 59, 48, 0.3); }
    }

    .recording-time {
      margin-top: 20px;
      font-size: 24px;
      font-weight: 300;
      color: #333;
      font-variant-numeric: tabular-nums;
    }

    .recording-status {
      margin-top: 10px;
      font-size: 14px;
      color: #666;
    }

    /* Navigation Buttons */
    .navigation {
      display: flex;
      justify-content: space-between;
      padding: 20px 24px;
      border-top: 1px solid #e5e5e5;
      background: #fafafa;
    }

    .btn {
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
    }

    .btn-secondary {
      background: white;
      color: #666;
      border: 1px solid #d1d1d1;
    }

    .btn-secondary:hover {
      background: #f7f7f7;
      border-color: #999;
    }

    .btn-primary {
      background: #5E5CE6;
      color: white;
    }

    .btn-primary:hover {
      background: #4B49D8;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(94, 92, 230, 0.3);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Success/Info Messages */
    .info-message {
      padding: 12px 16px;
      border-radius: 6px;
      margin-bottom: 20px;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .info-message.success {
      background: #E8F5E9;
      color: #2E7D32;
      border: 1px solid #A5D6A7;
    }

    .info-message.info {
      background: #E3F2FD;
      color: #1565C0;
      border: 1px solid #90CAF9;
    }

    .info-message.warning {
      background: #FFF3E0;
      color: #EF6C00;
      border: 1px solid #FFB74D;
    }

    .option-card {
  border: 1px solid #e5e5e5;
  border-radius: 8px;
  padding: 15px;
  margin: 10px 0;
}

.option-card h4 {
  margin-top: 0;
  color: #333;
}
  </style>
</head>
<body>
  <!-- Progress Bar -->
  <div class="progress-bar">
    <div class="progress-step active" data-step="1">
      <div class="step-circle">1</div>
      <div class="step-label">Basic Info</div>
    </div>
    <div class="progress-step" data-step="2">
      <div class="step-circle">2</div>
      <div class="step-label">Meeting Setup</div>
    </div>
    <div class="progress-step" data-step="3">
      <div class="step-circle">3</div>
      <div class="step-label">Recording</div>
    </div>
    <div class="progress-step" data-step="4">
      <div class="step-circle">4</div>
      <div class="step-label">Summary</div>
    </div>
  </div>

  <!-- Page Container -->
  <div class="page-container">
    <!-- Page 1: Basic Information -->
    <div class="page active" id="page1">
      <h2 style="margin-bottom: 24px;">Meeting Configuration</h2>
      
      <div class="form-group">
        <label>Your Role *</label>
        <div class="radio-group">
          <div class="radio-item">
            <input type="radio" id="student" name="role" value="student" checked>
            <label for="student" style="margin: 0;">Student</label>
          </div>
          <div class="radio-item">
            <input type="radio" id="tutor" name="role" value="tutor">
            <label for="tutor" style="margin: 0;">Tutor/Instructor</label>
          </div>
        </div>
      </div>

      <div class="form-group">
        <label for="module">Course Module *</label>
        <select id="module" required>
          <option value="">Select a module...</option>
          <option value="DE4 ERO">DE4 ERO</option>
          <option value="IDE2 TTL">IDE2 TTL</option>
          <option value="DE3 Futures ">DE3 Futures</option>
          <option value="DE3 I&E">DE3 I&E</option>
          <option value="xxx">xxx</option>
        </select>
      </div>

      <div class="form-group">
        <label for="meeting-type">Meeting Type *</label>
        <select id="meeting-type" required>
          <option value="">Select meeting type...</option>
          <option value="brainstorming">Brainstorming Session</option>
          <option value="decision-making">Decision Making</option>
          <option value="progress-update">Progress Update</option>
          <option value="problem-solving">Problem Solving</option>
          <option value="retrospective">Retrospective</option>
        </select>
      </div>

      <div class="form-group">
        <label for="team-members">Team Members (optional)</label>
        <input type="text" id="team-members" placeholder="Enter names separated by commas">
        <small style="color: #999; font-size: 11px; margin-top: 4px; display: block;">
          This helps with speaker identification
        </small>
      </div>

      <div class="form-group">
        <label for="meeting-goals">Meeting Goals (optional)</label>
        <textarea id="meeting-goals" placeholder="What do you hope to achieve in this meeting?"></textarea>
      </div>
    </div>

    <!-- Page 2: File Upload & Settings -->
    <div class="page" id="page2">
      <h2 style="margin-bottom: 24px;">Upload Supporting Materials</h2>
      
      <div class="info-message info">
        <span>ğŸ’¡</span>
        <span>Upload any relevant documents to provide context for better AI analysis</span>
      </div>

      <div class="form-group">
        <label>Supporting Documents (optional)</label>
        <div class="upload-area" id="uploadArea">
          <div class="upload-icon">ğŸ“</div>
          <div class="upload-text">Click to upload or drag and drop</div>
          <div class="upload-hint">PDF, DOC, DOCX, TXT, Images (Max 10MB)</div>
          <input type="file" id="fileInput" multiple accept=".pdf,.doc,.docx,.txt,.png,.jpg,.jpeg" style="display: none;">
        </div>
        <div class="file-list" id="fileList"></div>
      </div>

      <div class="form-group">
        <label>Analysis Preferences</label>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="key-decisions" checked>
            <label for="key-decisions" style="margin: 0;">Extract Key Decisions</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="action-items" checked>
            <label for="action-items" style="margin: 0;">Identify Action Items</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="speaker-analysis">
            <label for="speaker-analysis" style="margin: 0;">Analyze Speaker Contributions</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="sentiment-analysis">
            <label for="sentiment-analysis" style="margin: 0;">Include Sentiment Analysis</label>
          </div>
        </div>
      </div>
    </div>

    <!-- Page 3: Recording -->
<div class="page" id="page3">
  <h2 style="margin-bottom: 24px;">Start Recording</h2>

  <div id="recording-interface"></div>
    
    <!-- æ·»åŠ å½•éŸ³é—´éš”è®¾ç½® -->
    <div style="margin-top: 30px;">
      <label for="cycleInput">Summary interval (minutes):</label>
      <input id="cycleInput" type="number" value="5" min="1" max="30" 
             style="width: 80px; padding: 8px; margin-left: 10px;">
    </div>
    
    <div style="margin-top: 40px;">
      <div class="info-message info" style="text-align: left;">
        <span>â„¹ï¸</span>
        <div>
          <strong>Recording Instructions:</strong><br>
          â€¢ A new window will open for recording<br>
          â€¢ Allow microphone access when prompted<br>  
          â€¢ Recording will auto-save every 5 minutes<br>
          â€¢ You can stop recording from this page
        </div>
      </div>
    </div>
  </div>
  
  <!-- æ·»åŠ åœæ­¢æŒ‰é’®ï¼ˆåˆå§‹éšè—ï¼‰ -->
  <div style="text-align: center; margin-top: 20px;">
    <button class="btn btn-secondary" id="stopRecordingBtn" style="display: none;">
      Stop Recording
    </button>
  </div>
</div>

  <!-- Navigation -->
  <div class="navigation">
    <button class="btn btn-secondary" id="prevBtn" onclick="changePage(-1)">Previous</button>
    <button class="btn btn-primary" id="nextBtn" onclick="changePage(1)">Next</button>
  </div>

  <script>
    // // ===== MODIFIED STORAGE SOLUTION FOR FIGMA PLUGIN =====
    // // Use in-memory storage and communicate with plugin for persistence
    
    // State Management (in-memory)
    let currentPage = 1;
    const totalPages = 4;
    let formData = {
      role: 'student',
      module: '',
      meetingType: '',
      teamMembers: [],
      meetingGoals: '',
      files: [],
      preferences: {
        keyDecisions: true,
        actionItems: true,
        speakerAnalysis: false,
        sentimentAnalysis: false
      },
      additionalContext: '',
      pdfText: '',
      pdfFileName: ''
    };

    // // Recording state
     let isRecording = false;
    // let recordingStartTime = null;
    // let recordingInterval = null;
    // let mediaRecorder = null;
    // let audioChunks = [];

    // ===== STORAGE FUNCTIONS (Modified for Figma) =====
    
    // Save data to plugin storage via postMessage
    function saveToPluginStorage(key, value) {
      parent.postMessage({
        pluginMessage: {
          type: 'save-storage',
          key: key,
          value: value
        }
      }, '*');
    }

    // Request data from plugin storage
    function loadFromPluginStorage(key) {
      parent.postMessage({
        pluginMessage: {
          type: 'load-storage',
          key: key
        }
      }, '*');
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      updatePageDisplay();
      setupEventListeners();
      // Request saved data from plugin
      loadFromPluginStorage('meetingFormData');
    });

    // Listen for messages from plugin
    window.onmessage = (event) => {
      const message = event.data.pluginMessage;
      if (!message) return;

      switch (message.type) {
        case 'storage-loaded':
          if (message.key === 'meetingFormData' && message.value) {
            formData = message.value;
            restoreFormFields();
          }
          break;
        case 'processing-complete':
          displaySummaryResults(message.results);
          break;
        case 'processing-error':
          showMessage(message.error, 'warning');
          break;
      }
    };

    // Page Navigation
    function changePage(direction) {
      // Save current page data
      savePageData();

      // Validate before moving forward
      if (direction > 0 && !validateCurrentPage()) {
        showMessage('Please fill in all required fields', 'warning');
        return;
      }

      // Change page
      currentPage += direction;
      if (currentPage < 1) currentPage = 1;
      if (currentPage > totalPages) currentPage = totalPages;

      // Special handling for recording page
      if (currentPage === 3) {
        prepareRecordingPage();
      }

      // Update display
      updatePageDisplay();
      
      // Animate transition
      animatePageTransition();
    }

    function updatePageDisplay() {
      // Hide all pages
      document.querySelectorAll('.page').forEach(page => {
        page.classList.remove('active');
      });

      // Show current page
      document.getElementById(`page${currentPage}`).classList.add('active');

      // Update progress bar
      document.querySelectorAll('.progress-step').forEach((step, index) => {
        if (index < currentPage - 1) {
          step.classList.add('completed');
          step.classList.remove('active');
        } else if (index === currentPage - 1) {
          step.classList.add('active');
          step.classList.remove('completed');
        } else {
          step.classList.remove('active', 'completed');
        }
      });

      // Update navigation buttons
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');

      prevBtn.style.display = currentPage === 1 ? 'none' : 'block';
      
      if (currentPage === 3) {
        nextBtn.textContent = 'Finish Recording';
        nextBtn.style.display = isRecording ? 'block' : 'none';
      } else if (currentPage === 4) {
        nextBtn.style.display = 'none';
      } else {
        nextBtn.textContent = 'Next';
        nextBtn.style.display = 'block';
      }
    }

    function animatePageTransition() {
      const activePage = document.querySelector('.page.active');
      activePage.style.animation = 'none';
      setTimeout(() => {
        activePage.style.animation = 'fadeIn 0.3s ease';
      }, 10);
    }

    // Event Listeners Setup
    function setupEventListeners() {
      // File upload
      const uploadArea = document.getElementById('uploadArea');
      const fileInput = document.getElementById('fileInput');

      if (uploadArea && fileInput) {
        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
          e.preventDefault();
          uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
          uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
          e.preventDefault();
          uploadArea.classList.remove('dragover');
          handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
          handleFiles(e.target.files);
        });
      }

      // Radio buttons visual feedback
      document.querySelectorAll('.radio-item').forEach(item => {
        item.addEventListener('click', () => {
          document.querySelectorAll('.radio-item').forEach(i => i.classList.remove('selected'));
          item.classList.add('selected');
          item.querySelector('input[type="radio"]').checked = true;
        });
      });

      // Checkbox visual feedback
      document.querySelectorAll('.checkbox-item').forEach(item => {
        item.addEventListener('click', () => {
          const checkbox = item.querySelector('input[type="checkbox"]');
          checkbox.checked = !checkbox.checked;
          item.classList.toggle('selected', checkbox.checked);
        });
      });

      // Recording button
      const recordButton = document.getElementById('recordButton');
      if (recordButton) {
        recordButton.addEventListener('click', toggleRecording);
      }

      const stopBtn = document.getElementById('stopRecordingBtn');

       const stopRecordingBtn = document.getElementById('stopRecordingBtn');
  if (stopRecordingBtn) {
    stopRecordingBtn.addEventListener('click', () => {
      console.log('Stop button clicked');
      stopExternalRecording();  // è°ƒç”¨åœæ­¢å‡½æ•°
    });
  }

    }

    // File Handling
    // File Handling
async function handleFiles(files) {
  const fileList = document.getElementById('fileList');
  
  for (const file of Array.from(files)) {
    // Validate file
    if (file.size > 10 * 1024 * 1024) {
      showMessage(`File ${file.name} is too large (max 10MB)`, 'warning');
      continue;
    }

    // å¦‚æœæ˜¯PDFæ–‡ä»¶ï¼Œè¿›è¡Œç‰¹æ®Šå¤„ç†
    if (file.type === 'application/pdf') {
      console.log('ğŸ“„ Processing PDF file:', file.name);
      
      // ä¿å­˜æ–‡ä»¶å
      formData.pdfFileName = file.name;
      
      // ä½¿ç”¨æœåŠ¡å™¨ç«¯PDFå¤„ç†
      try {
        showMessage('Processing PDF...', 'info');
        
        const pdfFormData = new FormData();
        pdfFormData.append('file', file);
        
        const response = await fetch(`${API_CONFIG.BASE_URL}/api/ingest_pdf`, {
          method: 'POST',
          body: pdfFormData
        });
        
        const result = await response.json();
        
        if (result?.text && result.text.length > 0) {
          formData.pdfText = result.text;
  formData.pdfFileName = file.name;  // ç¡®ä¿æ–‡ä»¶åä¹Ÿè¢«ä¿å­˜
  
  // æ·»åŠ è¿™äº›è°ƒè¯•æ—¥å¿—
  console.log('âœ… PDFå¤„ç†å®Œæˆ:');
  console.log('  - æ–‡ä»¶å:', formData.pdfFileName);
  console.log('  - æ–‡æœ¬é•¿åº¦:', formData.pdfText.length);
  console.log('  - å‰100å­—ç¬¦:', formData.pdfText.substring(0, 100));
          showMessage(`PDF processed: ${(result.text.length/1000).toFixed(1)}k characters`, 'success');
        } else {
          showMessage('Could not extract text from PDF', 'warning');
        }
      } catch (err) {
        console.error('PDF processing error:', err);
        showMessage('Failed to process PDF', 'warning');
      }
    }

    // Store file metadata
    formData.files.push({
      name: file.name,
      size: file.size,
      type: file.type
    });

    // Display file
    const fileItem = document.createElement('div');
    fileItem.className = 'file-item';
    fileItem.innerHTML = `
      <span class="file-name">${file.name}</span>
      <span class="file-remove" onclick="removeFile('${file.name}')">âœ•</span>
    `;
    fileList.appendChild(fileItem);

    // Send file info to plugin
    parent.postMessage({
      pluginMessage: {
        type: 'file-upload',
        fileName: file.name,
        fileType: file.type,
        fileSize: file.size
      }
    }, '*');
  }
}

// Make removeFile globally accessible
window.removeFile = function(fileName) {
  console.log('Removing file:', fileName);
  formData.files = formData.files.filter(f => f.name !== fileName);
  updateFileList();
  
  // å¦‚æœæ˜¯PDFæ–‡ä»¶ï¼Œæ¸…é™¤PDFæ–‡æœ¬
  if (fileName === formData.pdfFileName) {
    formData.pdfText = '';
    formData.pdfFileName = '';
    console.log('Cleared PDF text cache');
  }
}

// Update file list display
function updateFileList() {
  const fileList = document.getElementById('fileList');
  if (!fileList) {
    console.warn('fileList element not found');
    return;
  }
  
  fileList.innerHTML = '';
  
  if (!formData.files || formData.files.length === 0) {
    console.log('No files to display');
    return;
  }
  
  formData.files.forEach(file => {
    const fileItem = document.createElement('div');
    fileItem.className = 'file-item';
    fileItem.innerHTML = `
      <span class="file-name">${file.name}</span>
      <span class="file-remove" onclick="removeFile('${file.name}')">âœ•</span>
    `;
    fileList.appendChild(fileItem);
  });
  
  console.log(`Updated file list with ${formData.files.length} files`);
}
 

    // Recording Functions
    async function toggleRecording() {
      if (!isRecording) {
        await startRecording();
      } else {
        stopRecording();
      }
    }

    async function startRecording() {
      try {
        // Request microphone access
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Create MediaRecorder
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          audioChunks.push(event.data);
        };

        mediaRecorder.onstop = async () => {
          // Create audio blob
          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          
          // Process recording
          await processRecording(audioBlob);
        };

        // Start recording
        mediaRecorder.start();
        isRecording = true;
        recordingStartTime = Date.now();

        // Update UI
        document.getElementById('recordButton').classList.add('recording');
        document.getElementById('recordButtonText').textContent = 'Stop Recording';
        document.getElementById('recordingStatus').textContent = 'Recording in progress...';
        document.getElementById('nextBtn').style.display = 'block';

        // Start timer
        recordingInterval = setInterval(updateRecordingTime, 1000);

      } catch (error) {
        console.error('Error starting recording:', error);
        showMessage('Failed to access microphone. Please check permissions.', 'warning');
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
        
        // Stop all tracks
        mediaRecorder.stream.getTracks().forEach(track => track.stop());
        
        isRecording = false;
        clearInterval(recordingInterval);

        // Update UI
        document.getElementById('recordButton').classList.remove('recording');
        document.getElementById('recordButtonText').textContent = 'Processing...';
        document.getElementById('recordingStatus').textContent = 'Processing your recording...';
        document.getElementById('recordButton').disabled = true;
      }
    }

    // function updateRecordingTime() {
    //   const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
    //   const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
    //   const seconds = (elapsed % 60).toString().padStart(2, '0');
    //   document.getElementById('recordingTime').textContent = `${minutes}:${seconds}`;
    // }

    // async function processRecording(audioBlob) {
    //   // Move to summary page
    //   currentPage = 4;
    //   updatePageDisplay();

    //   // Convert blob to base64 for Figma plugin communication
    //   const reader = new FileReader();
    //   reader.onloadend = () => {
    //     parent.postMessage({
    //       pluginMessage: {
    //         type: 'process-recording',
    //         formData: formData,
    //         audioData: reader.result
    //       }
    //     }, '*');
    //   };
    //   reader.readAsDataURL(audioBlob);
    // }

    // Form Validation
    function validateCurrentPage() {
      if (currentPage === 1) {
        const module = document.getElementById('module').value;
        const meetingType = document.getElementById('meeting-type').value;
        
        if (!module || !meetingType) {
          return false;
        }
      }
      return true;
    }

    // Data Persistence
    function savePageData() {
      if (currentPage === 1) {
        formData.role = document.querySelector('input[name="role"]:checked').value;
        formData.module = document.getElementById('module').value;
        formData.meetingType = document.getElementById('meeting-type').value;
        formData.teamMembers = document.getElementById('team-members').value.split(',').map(s => s.trim()).filter(Boolean);
        formData.meetingGoals = document.getElementById('meeting-goals').value;
      } else if (currentPage === 2) {
        formData.preferences.keyDecisions = document.getElementById('key-decisions').checked;
        formData.preferences.actionItems = document.getElementById('action-items').checked;
        formData.preferences.speakerAnalysis = document.getElementById('speaker-analysis').checked;
        formData.preferences.sentimentAnalysis = document.getElementById('sentiment-analysis').checked;
      }

      // Save to plugin storage
      saveToPluginStorage('meetingFormData', formData);
    }

    function restoreFormFields() {
      // Page 1 fields
      if (document.getElementById('module')) {
        document.getElementById('module').value = formData.module || '';
        document.getElementById('meeting-type').value = formData.meetingType || '';
        document.getElementById('team-members').value = formData.teamMembers.join(', ');
        document.getElementById('meeting-goals').value = formData.meetingGoals || '';
        
        // Radio buttons
        document.querySelector(`input[name="role"][value="${formData.role}"]`).checked = true;
      }

      // Page 2 fields
      if (document.getElementById('key-decisions')) {
        document.getElementById('key-decisions').checked = formData.preferences.keyDecisions;
        document.getElementById('action-items').checked = formData.preferences.actionItems;
        document.getElementById('speaker-analysis').checked = formData.preferences.speakerAnalysis;
        document.getElementById('sentiment-analysis').checked = formData.preferences.sentimentAnalysis;
      }

      // Update file list
      if (document.getElementById('fileList')) {
      updateFileList();
    }
  }

   function prepareRecordingPage() {
  // è·å–recording-interfaceå…ƒç´ ï¼ˆæ–°çš„å®¹å™¨ï¼‰
  const recordingInterface = document.getElementById('recording-interface');
  
  if (!recordingInterface) {
    console.warn('recording-interface element not found');
    // å¦‚æœæ–°å…ƒç´ ä¸å­˜åœ¨ï¼Œå°è¯•ä½¿ç”¨æ—§çš„ç»“æ„
    const readyMessage = document.getElementById('readyMessage');
    if (readyMessage) {
      // ä½¿ç”¨æ—§çš„æ–¹å¼
      let messageContent = `
        <span>âœ…</span>
        <div>
          <strong>Ready to record!</strong><br>
          Module: ${formData.module.replace('-', ' ')}<br>
          Meeting Type: ${formData.meetingType.replace('-', ' ')}<br>`;
      
      if (formData.files.length > 0) {
        messageContent += `${formData.files.length} supporting file(s) uploaded<br>`;
      }
      
      if (formData.pdfText && formData.pdfText.length > 0) {
        messageContent += `ğŸ“„ PDF loaded: ${(formData.pdfText.length/1000).toFixed(1)}k characters<br>`;
      }
      
      messageContent += `</div>`;
      readyMessage.innerHTML = messageContent;
    }
    return;
  }
  
  // ä½¿ç”¨æ–°çš„ç•Œé¢ï¼ˆæš‚æ—¶æ˜¾ç¤ºç®€å•ä¿¡æ¯ï¼‰
  recordingInterface.innerHTML = `
    <div class="info-message success">
      <span>âœ…</span>
      <div>
        <strong>Ready to record!</strong><br>
        Module: ${formData.module || 'Not set'}<br>
        Meeting Type: ${formData.meetingType || 'Not set'}<br>
        ${formData.files.length > 0 ? formData.files.length + ' file(s) uploaded<br>' : ''}
        ${formData.pdfText ? 'ğŸ“„ PDF loaded: ' + (formData.pdfText.length/1000).toFixed(1) + 'k characters' : ''}
      </div>
    </div>
    
    <div class="recording-interface">
      <button class="record-button" id="recordButton">
        <span id="recordButtonText">Open Recorder</span>
      </button>
      
      <div class="recording-status" id="recordingStatus">Ready to record</div>
      
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
      <button class="btn btn-secondary" id="stopRecordingBtn" style="display: none;">
        Stop Recording
      </button>
    </div>
  `;
  
  // é‡æ–°ç»‘å®šäº‹ä»¶
  const recordButton = document.getElementById('recordButton');
  if (recordButton) {
    recordButton.addEventListener('click', toggleRecording);
  }
  
  const stopBtn = document.getElementById('stopRecordingBtn');
  if (stopBtn) {
    stopBtn.addEventListener('click', stopExternalRecording);
  }
}

    // Summary Display
    function displaySummaryResults(results) {
      const page4 = document.getElementById('page4');
      page4.innerHTML = `
        <h2 style="margin-bottom: 24px;">Meeting Summary</h2>
        <div style="background: #f7f7f7; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
          <h3 style="margin-bottom: 8px;">Overview</h3>
          <p>${results.overview || 'Processing...'}</p>
        </div>
        <div style="margin-top: 24px; text-align: center;">
          <button class="btn btn-primary" onclick="insertToFigma()">Insert to Figma</button>
        </div>
      `;
    }

    // Figma Integration
    window.insertToFigma = function() {
      parent.postMessage({
        pluginMessage: {
          type: 'insert-summary',
          data: formData
        }
      }, '*');
    }

    // Utility Functions
    function showMessage(message, type = 'info') {
      const messageDiv = document.createElement('div');
      messageDiv.className = `info-message ${type}`;
      messageDiv.style.position = 'fixed';
      messageDiv.style.top = '20px';
      messageDiv.style.left = '50%';
      messageDiv.style.transform = 'translateX(-50%)';
      messageDiv.style.zIndex = '1000';
      messageDiv.innerHTML = `<span>${message}</span>`;
      
      document.body.appendChild(messageDiv);
      
      setTimeout(() => {
        messageDiv.remove();
      }, 3000);
    }

    // Make changePage globally accessible
    window.changePage = changePage;

    // ===== é…ç½®ç®¡ç† =====
// ç§»é™¤ç¡¬ç¼–ç çš„BASE_URLï¼Œæ”¹ä¸ºç¯å¢ƒå˜é‡æˆ–åŠ¨æ€é…ç½®
// ä¿®æ”¹ changePage å‡½æ•°
function changePage(direction) {
  // å¦‚æœåœ¨å½•éŸ³é¡µé¢ä¸”æ­£åœ¨å½•éŸ³ï¼Œå…ˆåœæ­¢
  if (currentPage === 3 && direction > 0 && isExternalRecording) {
    stopExternalRecording();
    return;
  }
  
  // ä¿å­˜å½“å‰é¡µé¢æ•°æ®
  savePageData();
  
  // éªŒè¯
  if (direction > 0 && !validateCurrentPage()) {
    showMessage('Please fill in all required fields', 'warning');
    return;
  }
  
  // åˆ‡æ¢é¡µé¢
  currentPage += direction;
  if (currentPage < 1) currentPage = 1;
  if (currentPage > totalPages) currentPage = totalPages;
  
  // å‡†å¤‡å½•éŸ³é¡µé¢
  if (currentPage === 3) {
    prepareRecordingPage();
  }
  
  updatePageDisplay();
  animatePageTransition();
}
const API_CONFIG = {
  // ä»ç¯å¢ƒè·å–æˆ–ä½¿ç”¨é»˜è®¤å€¼
  BASE_URL: window.API_BASE_URL || 'https://fyp-2025-kath.vercel.app',
  endpoints: {
    controlSignals: '/api/stop',
    sessions: '/api/get',
    savePdf: '/api/save_pdf',
    stopRecording: '/api/stop',
    ingestPdf: '/api/ingest_pdf'
  },
  // è½®è¯¢é…ç½®
  polling: {
    interval: 2000,
    maxRetries: 3,
    timeout: 30000
  }
};

// ===== å½•éŸ³ç›¸å…³å…¨å±€å˜é‡ï¼ˆä¿æŒä¸å˜ï¼‰=====
let recordingWindow = null;
let recordingSessionId = null;
let isExternalRecording = false;
let pollInterval = null;
let pollRetryCount = 0;

// ===== ç»Ÿä¸€çš„APIè°ƒç”¨å‡½æ•°ï¼ˆæ–°å¢ï¼‰=====
async function apiCall(endpoint, options = {}) {
  const url = endpoint.startsWith('http') 
    ? endpoint 
    : `${API_CONFIG.BASE_URL}${endpoint}`;
  
  const defaultOptions = {
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    },
    ...options
  };
  
  try {
    const response = await fetch(url, defaultOptions);
    
    if (!response.ok) {
      throw new Error(`API call failed: ${response.status} ${response.statusText}`);
    }
    
    return response;
  } catch (error) {
    console.error(`API call error for ${endpoint}:`, error);
    
    // å¢åŠ é‡è¯•é€»è¾‘
    if (options.retry !== false && pollRetryCount < API_CONFIG.polling.maxRetries) {
      pollRetryCount++;
      console.log(`Retrying API call (${pollRetryCount}/${API_CONFIG.polling.maxRetries})...`);
      await new Promise(resolve => setTimeout(resolve, 1000));
      return apiCall(endpoint, { ...options, retry: false });
    }
    
    throw error;
  }
}

// ===== ä¿®æ”¹ toggleRecording å‡½æ•°ï¼ˆä¿æŒä¸å˜ï¼‰=====
async function toggleRecording() {
  await openExternalRecorder();
}

// ===== ä¼˜åŒ–çš„æ‰“å¼€å¤–éƒ¨å½•éŸ³çª—å£å‡½æ•° =====
async function openExternalRecorder() {
  console.log('ğŸš€ å‡†å¤‡å½•éŸ³ä¼šè¯');
  
  // ç”Ÿæˆsession ID
  recordingSessionId = Date.now().toString();
  
  // è·å–è®¾ç½®
  const cycleInput = document.getElementById('cycleInput');
  const intervalMin = cycleInput ? parseInt(cycleInput.value || '5', 10) : 5;
  
  // å…ˆä¿å­˜æ‰€æœ‰é…ç½®åˆ°æœåŠ¡å™¨
  const setupSuccess = await setupRecordingSession(intervalMin);
  
  if (!setupSuccess) {
    showMessage('Failed to setup recording session', 'warning');
    return;
  }
  
  // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„ç•Œé¢ï¼Œè®©ç”¨æˆ·ä¸»åŠ¨æ‰“å¼€å½•éŸ³é¡µé¢
  showRecordingInstructions(intervalMin);
}

async function setupRecordingSession(intervalMin) {
  try {
    console.log('ğŸ“¡ ä¿å­˜ä¼šè¯è®¾ç½®...');
    
    // 1. ä¿å­˜é…ç½®
    await apiCall(API_CONFIG.endpoints.controlSignals, {
      method: 'POST',
      body: JSON.stringify({
        session_id: recordingSessionId,
        command: 'set_cycle',
        value: intervalMin
      })
    });
    console.log('âœ… é—´éš”è®¾ç½®å·²ä¿å­˜');
    
    // 2. å¦‚æœæœ‰PDFï¼Œä¿å­˜å®ƒ
    if (formData.pdfText && formData.pdfText.trim().length > 0) {
      console.log('ğŸ“„ ä¿å­˜PDFå†…å®¹...');
      const pdfSaved = await savePdfToServer(recordingSessionId, formData.pdfText);
      if (pdfSaved) {
        console.log('âœ… PDFå·²ä¿å­˜');
      } else {
        console.warn('âš ï¸ PDFä¿å­˜å¤±è´¥ï¼Œä½†ç»§ç»­');
      }
    }
    
    return true;
  } catch (err) {
    console.error('Setup failed:', err);
    return false;
  }
}

function showRecordingInstructions(intervalMin) {
  const recordingURL = `${API_CONFIG.BASE_URL}/record.html?session=${recordingSessionId}&start=true`;
  
  // æ›´æ–°å½•éŸ³é¡µé¢UI
  const recordingInterface = document.getElementById('recording-interface');
  if (recordingInterface) {
    recordingInterface.innerHTML = `
      <div style="text-align: center; padding: 20px;">
        <div class="info-message success" style="margin-bottom: 20px;">
          <span>âœ…</span>
          <span>Recording session ready! Choose how to open:</span>
        </div>
        
        <div style="background: #f7f7f7; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
          <p><strong>Session ID:</strong> ${recordingSessionId}</p>
          <p><strong>Auto-save:</strong> Every ${intervalMin} minutes</p>
          ${formData.pdfText ? '<p>âœ… PDF document uploaded</p>' : ''}
        </div>
        
        <!-- Option 1: Copy Link -->
        <button class="btn btn-primary" onclick="copyRecordingLink('${recordingURL}')" style="margin: 10px;">
          ğŸ“‹ Copy Recording Link
        </button>
        
        <!-- Option 2: Try to Open -->
        <button class="btn btn-secondary" onclick="attemptOpenRecorder('${recordingURL}')" style="margin: 10px;">
          ğŸ”— Open Recording Page
        </button>
        
        <div style="margin-top: 30px;">
          <button class="btn btn-secondary" onclick="checkRecordingStatus()">
            Check Status
          </button>
          <button class="btn btn-secondary" onclick="stopExternalRecording()" style="margin-left: 10px;">
            Stop Recording
          </button>
        </div>
      </div>
    `;
  }
  
  // å¼€å§‹è½®è¯¢
  startPolling(recordingSessionId);
  
  // æ›´æ–°çŠ¶æ€
  isExternalRecording = true;
  isRecording = true;
  updateRecordingUI(true);
}
async function stopExternalRecording() {
  console.log('ğŸ›‘ Stopping external recording...');
  
  // 1. å‘é€åœæ­¢ä¿¡å·åˆ°æœåŠ¡å™¨
  if (recordingSessionId) {
    try {
      await apiCall(API_CONFIG.endpoints.stopRecording, {
        method: 'POST',
        body: JSON.stringify({
          session_id: recordingSessionId,
          command: 'stop'
        })
      });
      console.log('âœ… Stop signal sent');
    } catch (err) {
      console.error('Error sending stop signal:', err);
    }
  }
  
  // 2. å…³é—­å½•éŸ³çª—å£
  if (recordingWindow && !recordingWindow.closed) {
    recordingWindow.close();
  }
  
  // 3. åœæ­¢è½®è¯¢
  if (pollInterval) {
    clearInterval(pollInterval);
    pollInterval = null;
  }
  
  // 4. æ›´æ–°çŠ¶æ€
  isExternalRecording = false;
  isRecording = false;
  
  // 5. æ›´æ–°UI - æ˜¾ç¤ºå¤„ç†ä¸­
  updateRecordingUI(false, true);
  showMessage('Recording stopped. Processing results...', 'info');
  
  // 6. è·å–æœ€ç»ˆç»“æœ
  setTimeout(async () => {
    try {
      const res = await apiCall(`${API_CONFIG.endpoints.sessions}?session=${recordingSessionId}`);
      const data = await res.json();
      
      if (data && data.summary) {
        // ä¿å­˜ç»“æœ
        formData.results = {
          transcript: data.transcript || '',
          summary: data.summary || '',
          decisions: data.decision || [],
          explicit: data.explicit || [],
          tacit: data.tacit || [],
          reasoning: data.reasoning || '',
          suggestions: data.suggestions || []
        };
        
        // æ˜¾ç¤ºç»“æœé¡µ
        currentPage = 4;
        updatePageDisplay();
        displaySummaryResults(formData.results);
      }
    } catch (err) {
      console.error('Error fetching final results:', err);
    }
    
    // é‡ç½®UI
    resetRecordingUI();
  }, 2000);
}


// ===== æ–°å¢ï¼šæ˜¾ç¤ºå¼¹çª—è¢«æ‹¦æˆªçš„æ¶ˆæ¯å’Œæ›¿ä»£æ–¹æ¡ˆ =====
function showPopupBlockedMessage() {
  const messageHTML = `
    <div id="popupBlockedMessage" style="
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border: 2px solid #ff9800;
      border-radius: 8px;
      padding: 20px;
      z-index: 10000;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      max-width: 400px;
    ">
      <h3 style="margin-top: 0; color: #ff9800;">âš ï¸ Popup Blocked</h3>
      <p>Your browser blocked the recording window. Please choose an option:</p>
      
      <div style="margin: 15px 0;">
        <button onclick="allowPopupAndRetry()" style="
          background: #4CAF50;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
          cursor: pointer;
          margin-right: 10px;
        ">
          Allow Popups & Retry
        </button>
        
        <button onclick="openInNewTab()" style="
          background: #2196F3;
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 4px;
          cursor: pointer;
        ">
          Open in New Tab
        </button>
      </div>
      
      <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
        <p style="margin: 0; font-size: 14px; color: #666;">
          <strong>To enable popups:</strong><br>
          1. Click the popup blocker icon in your browser's address bar<br>
          2. Select "Always allow popups from this site"<br>
          3. Click the recording button again
        </p>
      </div>
      
      <button onclick="closePopupMessage()" style="
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: #999;
      ">Ã—</button>
    </div>
  `;
  
  // æ·»åŠ åˆ°é¡µé¢
  const div = document.createElement('div');
  div.innerHTML = messageHTML;
  document.body.appendChild(div);
}

// ===== è¾…åŠ©å‡½æ•°ï¼šé‡è¯•æ‰“å¼€å¼¹çª— =====
window.allowPopupAndRetry = function() {
  closePopupMessage();
  
  // æç¤ºç”¨æˆ·å…ˆå…è®¸å¼¹çª—
  alert('Please allow popups for this site in your browser settings, then click OK to retry.');
  
  // é‡è¯•æ‰“å¼€
  setTimeout(() => {
    openExternalRecorder();
  }, 100);
};

// ===== è¾…åŠ©å‡½æ•°ï¼šåœ¨æ–°æ ‡ç­¾é¡µæ‰“å¼€ =====
window.openInNewTab = function() {
  closePopupMessage();
  
  // ç”Ÿæˆsession ID
  recordingSessionId = Date.now().toString();
  
  // åœ¨æ–°æ ‡ç­¾é¡µæ‰“å¼€
  const recordUrl = `${API_CONFIG.BASE_URL}/record.html?session=${recordingSessionId}&start=true`;
  const newTab = window.open(recordUrl, '_blank');
  
  if (newTab) {
    // æ›´æ–°UIçŠ¶æ€
    updateRecordingUI(true);
    isExternalRecording = true;
    isRecording = true;
    
    // å¼€å§‹è½®è¯¢
    startPolling(recordingSessionId);
    
    // è®¾ç½®è®°å½•çª—å£å¼•ç”¨
    recordingWindow = newTab;
    checkRecordingWindowStatus();
    
    // ä¿å­˜è®¾ç½®
    saveRecordingSettings(recordingSessionId);
  }
};

// ===== è¾…åŠ©å‡½æ•°ï¼šå…³é—­å¼¹çª—æ¶ˆæ¯ =====
window.closePopupMessage = function() {
  const message = document.getElementById('popupBlockedMessage');
  if (message) {
    message.parentElement.remove();
  }
};

// ===== è¾…åŠ©å‡½æ•°ï¼šä¿å­˜å½•éŸ³è®¾ç½® =====
async function saveRecordingSettings(sessionId) {
  const cycleInput = document.getElementById('cycleInput');
  const intervalMin = cycleInput ? parseInt(cycleInput.value || '5', 10) : 5;
  
  try {
    await apiCall(API_CONFIG.endpoints.controlSignals, {
      method: 'POST',
      body: JSON.stringify({
        session_id: sessionId,
        command: 'set_cycle',
        value: intervalMin
      })
    });
    
    if (formData.pdfText) {
      await savePdfToServer(sessionId, formData.pdfText);
    }
  } catch (err) {
    console.error('Error saving settings:', err);
  }
}

// ===== æ–°å¢ï¼šç›‘æ§å½•éŸ³çª—å£çŠ¶æ€ =====
function checkRecordingWindowStatus() {
  const checkInterval = setInterval(() => {
    if (recordingWindow && recordingWindow.closed) {
      // çª—å£è¢«ç”¨æˆ·å…³é—­
      console.log('Recording window was closed by user');
      clearInterval(checkInterval);
      
      if (isExternalRecording) {
        // å¦‚æœè¿˜åœ¨å½•éŸ³ä¸­ï¼Œåœæ­¢å½•éŸ³
        stopExternalRecording();
      }
    }
    
    if (!isExternalRecording) {
      // å½•éŸ³å·²åœæ­¢ï¼Œåœæ­¢æ£€æŸ¥
      clearInterval(checkInterval);
    }
  }, 1000);
}

// ===== æ›¿ä»£æ–¹æ¡ˆï¼šä½¿ç”¨å†…åµŒiframeï¼ˆå¦‚æœå…è®¸ï¼‰=====
function openRecorderInIframe() {
  const iframeHTML = `
    <div id="recorderIframeContainer" style="
      position: fixed;
      top: 10%;
      left: 10%;
      width: 80%;
      height: 80%;
      background: white;
      border: 2px solid #333;
      border-radius: 8px;
      z-index: 9999;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    ">
      <div style="
        background: #333;
        color: white;
        padding: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      ">
        <span>Recording Window</span>
        <button onclick="closeRecorderIframe()" style="
          background: #ff4444;
          color: white;
          border: none;
          padding: 5px 15px;
          border-radius: 4px;
          cursor: pointer;
        ">Close</button>
      </div>
      <iframe 
        id="recorderIframe"
        src="${API_CONFIG.BASE_URL}/record.html?session=${recordingSessionId}&start=true"
        style="width: 100%; height: calc(100% - 40px); border: none;">
      </iframe>
    </div>
  `;
  
  const div = document.createElement('div');
  div.innerHTML = iframeHTML;
  document.body.appendChild(div);
}

window.closeRecorderIframe = function() {
  const container = document.getElementById('recorderIframeContainer');
  if (container) {
    container.remove();
    if (isExternalRecording) {
      stopExternalRecording();
    }
  }
};
function startPolling(sessionId) {
  let lastShownSummary = '';
  let pollTimeoutId = null;
  
  // è®¾ç½®è¶…æ—¶
  pollTimeoutId = setTimeout(() => {
    if (pollInterval) {
      clearInterval(pollInterval);
      console.warn('Polling timeout reached');
      showError('Recording timeout. Please check your connection and try again.');
    }
  }, API_CONFIG.polling.timeout);
  
  pollInterval = setInterval(async () => {
    try {
      const res = await apiCall(`${API_CONFIG.endpoints.sessions}?session=${sessionId}`);
      const data = await res.json();
      
      if (data && data.summary && data.summary !== lastShownSummary) {
        lastShownSummary = data.summary;
        
        // æ¸…é™¤è¶…æ—¶
        if (pollTimeoutId) {
          clearTimeout(pollTimeoutId);
        }
        
        // å­˜å‚¨ç»“æœï¼ˆå¢åŠ æ•°æ®éªŒè¯ï¼‰
        formData.results = {
          transcript: data.transcript || '',
          summary: data.summary || '',
          decisions: Array.isArray(data.decision) ? data.decision : [],
          explicit: Array.isArray(data.explicit) ? data.explicit : [],
          tacit: Array.isArray(data.tacit) ? data.tacit : [],
          reasoning: data.reasoning || '',
          suggestions: Array.isArray(data.suggestions) ? data.suggestions : []
        };
        
        // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        await saveToPluginStorage('lastMeetingResults', formData.results);
        
        // å¦‚æœå½•éŸ³å·²åœæ­¢ï¼Œæ˜¾ç¤ºç»“æœ
        if (!isExternalRecording) {
          clearInterval(pollInterval);
          displaySummaryResults(formData.results);
          
          // å‘é€ç»™Figmaæ’ä»¶
          sendResultsToFigma(data);
        }
      }
    } catch (err) {
      console.error('Polling error:', err);
      // ä¸ç«‹å³åœæ­¢è½®è¯¢ï¼Œå¯èƒ½æ˜¯ä¸´æ—¶ç½‘ç»œé—®é¢˜
    }
  }, API_CONFIG.polling.interval);
}

// ===== ä¼˜åŒ–çš„PDFä¿å­˜å‡½æ•° =====

async function savePdfToServer(sessionId, pdfText) {
  console.log('ğŸ“š === å¼€å§‹ savePdfToServer å‡½æ•° ===');
  
  // è¾“å…¥éªŒè¯
  if (!sessionId) {
    console.error('âŒ æ²¡æœ‰session ID');
    return false;
  }
  
  if (!pdfText || pdfText.trim().length === 0) {
    console.error('âŒ PDFæ–‡æœ¬ä¸ºç©º');
    return false;
  }
  
  // é™åˆ¶å¤§å°
  const maxLength = 500000;
  let textToSave = pdfText;
  if (pdfText.length > maxLength) {
    console.warn(`âš ï¸ PDFå¤ªå¤§ (${pdfText.length}å­—ç¬¦), æˆªæ–­åˆ°${maxLength}å­—ç¬¦`);
    textToSave = pdfText.substring(0, maxLength);
  }
  
  // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
  console.log('ğŸ“‹ PDFä¿å­˜å‚æ•°:');
  console.log('  - APIç«¯ç‚¹:', `${API_CONFIG.BASE_URL}${API_CONFIG.endpoints.savePdf}`);
  console.log('  - Session ID:', sessionId);
  console.log('  - åŸå§‹æ–‡æœ¬é•¿åº¦:', pdfText.length);
  console.log('  - ä¿å­˜æ–‡æœ¬é•¿åº¦:', textToSave.length);
  console.log('  - æ–‡ä»¶å:', formData.pdfFileName || 'context.pdf');
  console.log('  - æ¨¡å—:', formData.module || 'unknown');
  console.log('  - ä¼šè®®ç±»å‹:', formData.meetingType || 'unknown');
  
  try {
    // æ„å»ºè¯·æ±‚ä½“
    const requestBody = {
      session_id: sessionId,
      pdf_text: textToSave,
      filename: formData.pdfFileName || 'context.pdf',
      metadata: {
        uploadTime: new Date().toISOString(),
        textLength: textToSave.length,
        module: formData.module || 'unknown',
        meetingType: formData.meetingType || 'unknown'
      }
    };
    
    console.log('ğŸ“¤ å‘é€POSTè¯·æ±‚åˆ°:', `${API_CONFIG.BASE_URL}${API_CONFIG.endpoints.savePdf}`);
    console.log('ğŸ“¤ è¯·æ±‚ä½“å¤§å°:', JSON.stringify(requestBody).length, 'å­—ç¬¦');
    
    // å‘é€è¯·æ±‚
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.endpoints.savePdf}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestBody)
    });
    
    console.log('ğŸ“¥ å“åº”çŠ¶æ€ç :', response.status);
    console.log('ğŸ“¥ å“åº”çŠ¶æ€æ–‡æœ¬:', response.statusText);
    console.log('ğŸ“¥ å“åº”å¤´:', {
      'content-type': response.headers.get('content-type'),
      'content-length': response.headers.get('content-length')
    });
    
    // è·å–å“åº”æ–‡æœ¬
    const responseText = await response.text();
    console.log('ğŸ“¥ åŸå§‹å“åº”å†…å®¹:', responseText);
    console.log('ğŸ“¥ å“åº”é•¿åº¦:', responseText.length, 'å­—ç¬¦');
    
    // æ£€æŸ¥HTTPçŠ¶æ€
    if (!response.ok) {
      console.error('âŒ æœåŠ¡å™¨è¿”å›é”™è¯¯çŠ¶æ€:', response.status);
      console.error('âŒ é”™è¯¯è¯¦æƒ…:', responseText);
      
      // å°è¯•è§£æé”™è¯¯ä¿¡æ¯
      try {
        const errorData = JSON.parse(responseText);
        console.error('âŒ é”™è¯¯å¯¹è±¡:', errorData);
      } catch (e) {
        console.error('âŒ é”™è¯¯å“åº”ä¸æ˜¯JSONæ ¼å¼');
      }
      
      return false;
    }
    
    // å°è¯•è§£æJSONå“åº”
    let result = null;
    try {
      result = JSON.parse(responseText);
      console.log('âœ… æˆåŠŸè§£æJSONå“åº”:', result);
      
      // æ£€æŸ¥å“åº”ä¸­çš„æˆåŠŸæ ‡å¿—
      if (result.ok || result.success || result.status === 'success') {
        console.log('âœ… PDFæˆåŠŸä¿å­˜åˆ°Supabase!');
        console.log('  - ä¿å­˜æ—¶é—´:', new Date().toISOString());
        console.log('  - Session:', sessionId);
        return true;
      } else {
        console.warn('âš ï¸ å“åº”ä¸­æ²¡æœ‰æ˜ç¡®çš„æˆåŠŸæ ‡å¿—');
        console.log('  - å“åº”å¯¹è±¡:', result);
      }
      
    } catch (parseError) {
      console.warn('âš ï¸ å“åº”ä¸æ˜¯æœ‰æ•ˆçš„JSON:', parseError.message);
      
      // å¦‚æœçŠ¶æ€ç æ˜¯200-299ï¼Œå³ä½¿ä¸æ˜¯JSONä¹Ÿè®¤ä¸ºæˆåŠŸ
      if (response.status >= 200 && response.status < 300) {
        console.log('âœ… åŸºäºHTTPçŠ¶æ€ç åˆ¤æ–­PDFå·²ä¿å­˜');
        console.log('  - çŠ¶æ€ç :', response.status);
        console.log('  - å“åº”å†…å®¹:', responseText.substring(0, 100));
        return true;
      }
    }
    
    // é»˜è®¤è¿”å›false
    console.warn('âš ï¸ æ— æ³•ç¡®è®¤PDFæ˜¯å¦ä¿å­˜æˆåŠŸ');
    return false;
    
  } catch (error) {
    console.error('âŒ PDFä¿å­˜è¿‡ç¨‹å‘ç”Ÿå¼‚å¸¸:', error);
    console.error('  - é”™è¯¯ç±»å‹:', error.name);
    console.error('  - é”™è¯¯æ¶ˆæ¯:', error.message);
    console.error('  - é”™è¯¯å †æ ˆ:', error.stack);
    
    // ç½‘ç»œé”™è¯¯ç‰¹æ®Šå¤„ç†
    if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
      console.error('âŒ ç½‘ç»œè¿æ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥:');
      console.error('  1. APIæœåŠ¡å™¨æ˜¯å¦è¿è¡Œ');
      console.error('  2. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸');
      console.error('  3. CORSè®¾ç½®æ˜¯å¦æ­£ç¡®');
    }
    
    return false;
    
  } finally {
    console.log('ğŸ“š === ç»“æŸ savePdfToServer å‡½æ•° ===');
  }
}

// ===== æ–°å¢è¾…åŠ©å‡½æ•° =====
function updateRecordingUI(isRecording, isProcessing = false) {
  const recordButton = document.getElementById('recordButton');
  const recordButtonText = document.getElementById('recordButtonText');
  const recordingStatus = document.getElementById('recordingStatus');
  const stopRecordingBtn = document.getElementById('stopRecordingBtn');
  const nextBtn = document.getElementById('nextBtn');
  
  if (isRecording) {
    recordButton?.classList.add('recording');
    if (recordButtonText) recordButtonText.textContent = 'Recording in Progress';
    if (recordingStatus) recordingStatus.textContent = 'Recording in external window - DO NOT CLOSE';
    if (stopRecordingBtn) stopRecordingBtn.style.display = 'block';
    if (nextBtn) nextBtn.style.display = 'none';
  } else if (isProcessing) {
    recordButton?.classList.remove('recording');
    if (recordButtonText) recordButtonText.textContent = 'Processing...';
    if (recordingStatus) recordingStatus.textContent = 'Processing your recording...';
    if (recordButton) recordButton.disabled = true;
    if (stopRecordingBtn) stopRecordingBtn.style.display = 'none';
  } else {
    resetRecordingUI();
  }
}

function resetRecordingUI() {
  const recordButton = document.getElementById('recordButton');
  const recordButtonText = document.getElementById('recordButtonText');
  const recordingStatus = document.getElementById('recordingStatus');
  const stopRecordingBtn = document.getElementById('stopRecordingBtn');
  const nextBtn = document.getElementById('nextBtn');
  
  recordButton?.classList.remove('recording');
  if (recordButtonText) recordButtonText.textContent = 'Start Recording';
  if (recordingStatus) recordingStatus.textContent = '';
  if (recordButton) recordButton.disabled = false;
  if (stopRecordingBtn) stopRecordingBtn.style.display = 'none';
  if (nextBtn) nextBtn.style.display = 'block';
}

function sendResultsToFigma(data) {
  parent.postMessage({
    pluginMessage: {
      type: 'analyze-transcript',
      transcript: data.transcript,
      summary: data.summary,
      decision: data.decision,
      explicit: data.explicit,
      tacit: data.tacit,
      reasoning: data.reasoning,
      suggestions: data.suggestions
    }
  }, '*');
}

function showError(message) {
  // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯çš„å‡½æ•°
  console.error(message);
  const errorDiv = document.getElementById('errorMessage');
  if (errorDiv) {
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
    setTimeout(() => {
      errorDiv.style.display = 'none';
    }, 5000);
  }
}

// ===== ä¿®æ”¹åŸæœ‰å‡½æ•°çš„å…¼å®¹æ€§åŒ…è£… =====
async function startRecording() {
  await openExternalRecorder();
}

function stopRecording() {
  if (isExternalRecording) {
    stopExternalRecording();
  }
}

// ===== åˆå§‹åŒ–æ—¶æ£€æŸ¥ç¯å¢ƒ =====
(function initializeAPIConfig() {
  // æ£€æŸ¥æ˜¯å¦åœ¨å¼€å‘ç¯å¢ƒ
  if (window.location.hostname === 'localhost') {
    API_CONFIG.BASE_URL = 'http://localhost:3000';
    console.log('Using local development server');
  }
  
  // æ£€æŸ¥æ˜¯å¦æœ‰è‡ªå®šä¹‰é…ç½®
  if (window.customAPIConfig) {
    Object.assign(API_CONFIG, window.customAPIConfig);
  }
})();

// å¤åˆ¶é“¾æ¥å‡½æ•°
window.copyRecordingLink = async function(url) {
  try {
    await navigator.clipboard.writeText(url);
    showMessage('Link copied! Paste it in your browser.', 'success');
  } catch (err) {
    // å¤‡ç”¨æ–¹æ³•
    const textArea = document.createElement('textarea');
    textArea.value = url;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    showMessage('Link copied!', 'success');
  }
}

// å°è¯•æ‰“å¼€å½•éŸ³é¡µé¢
window.attemptOpenRecorder = function(url) {
  console.log('ç”¨æˆ·ç‚¹å‡»æ‰“å¼€å½•éŸ³é¡µé¢');
  
  const newWindow = window.open(url, '_blank');
  
  if (!newWindow || newWindow.closed) {
    showMessage('Popup blocked. Please use "Copy Link" instead.', 'warning');
    // è‡ªåŠ¨å¤åˆ¶é“¾æ¥
    copyRecordingLink(url);
  } else {
    showMessage('Recording page opened!', 'success');
    recordingWindow = newWindow;
    checkRecordingWindowStatus();
  }
}

// æ£€æŸ¥å½•éŸ³çŠ¶æ€
window.checkRecordingStatus = async function() {
  try {
    const res = await fetch(`${API_CONFIG.BASE_URL}/api/get?session=${recordingSessionId}`);
    const data = await res.json();
    
    if (data && data.transcript) {
      showMessage('Recording in progress...', 'info');
    } else {
      showMessage('No recording detected yet', 'warning');
    }
  } catch (err) {
    showMessage('Could not check status', 'warning');
  }
}

  </script>
</body>
</html>

